

# 第一章



# 第二章

* 程序的输出在屏幕上一闪而过，可以在 return 语句前添加 getchar()

* #include: 预处理器指令

* 头文件中可以定义一些常量，或者声明函数名，==但是函数的实际代码在一个预编译代码的库文件中==
  
* 头文件帮助compiler把你的程序正确地组合在一起
  
* main() 总是第1个被调用的函数。调用 main函数后，依次调用其他函数

* 函数是C程序的基本模块，一个完整的函数声明如下：

  ​                      函数类型  函数名 ( 参数1类型,  参数2类型，...) ；

  * 注意声明时不必定义参数名，且圆括号与分号都不能少

*  完整函数定义：

  ​     函数类型  函数名  ( 参数1类型  参数1名称,  参数2类型 参数2名称, ... )

  ​       {

  ​            函数体

  ​        }

  * { 表示函数开始；} 表示函数结束

* 注释方法：/**/与 //

  * /**/中间无论是几行都是注释
  * // 后面一行是注释

* 所有的C函数都使用==花括号==标记函数体的开始和结束，花括号还可用于把函数中的多条语句合并为一个单元或块（把多条语句合并为一条复杂语句）

* 声明是C语言最重要的特性之一，编译器通过变量的类型信息在内存中分配存储空间。这一片空间在用户方的名字就是变量名，在机器中则是对应的地址。声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。

* 在C语言中，所有变量都必须先声明才能使用。这意味着必须列出程序中用到的所有变量名及其类型。

* 可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第1个字符必须是字符或下划线，不能是数字。C语言的名称区分大小写。

* 在C语言中，调用函数时传递的信息是实际参数，定义函数时的变量是形式参数

* 调用函数时，只需输入函数名，并把所需的参数填入圆括号即可，当程序运行到此行时控制权被转给已命名的参数。函数执行结束后，控制权返回至主调函数，即调用时所属的函数

* 提高代码可读性的技巧：
  * 选择有意义的函数名
  * 写注释
  * 在函数中将概念上的多个部分隔离开来，该空行空行
* 函数定义时形参的声明必须一个一个的声明：参数1类型 参数1名称；参数2类型 参数2名称；...
* 在函数体内声明局部变量时可以一个一个声明，也可以同类型一次多个声明，注意加分号
* 通常来说，用户定义的函数在一个程序中会出现三次：
  * 函数原型，即函数声明，告知compiler函数的签名信息
  * 函数调用
  * 函数定义
* ==何时执行函数取决于函数在main函数中被调用的位置==，与其他无关
  
  * 从main函数开始看一个C语言的程序
* 程序的错误：bug；找出bug并修正：debug
* bug类型：
  * 语法bug。可借助compiler调整
  * 语义bug。与预期输出不符，需要仔细检查。
* 程序状态：给定时间点上所有变量值的集合
* 对于compiler而言，几乎正确仍然是错误
* 函数调用语句实质上是表达式语句，函数调用本身是一个表达式，圆括号是运算符，圆括号左边的函数名是运算对象



# 第三章 数据和C

两大数据类型：整数类型、浮点数类型

* scanf函数的几点说明
  * scanf(" ... ", ... , ... ,....)
  * scanf接受的数据类型是字符串和指针
  * 接受多少个指针类型与字符串中有多少个占位符有关
  * scanf只接受输入，无法输出
  * 如果格式符中没有间隔，可以在输入时用空格或回车作为输入的间隔
* float类型可以存储带小数的数字，在printf中使用 %f来打印float类型的变量，且可以使用%.nf控制精确输出小数点后n位的数据
  * 不要在浮点型常量中间加空格
* 常量 constant ：在程序运行期间没有变化
* 变量 variable ：在程序运行期间会改变或被赋值
* 定义变量需要声明数据类型，定义常量==直接#define 常量名称 常量值 即可，不需声明类型==
* 存储单元：
  * 位 bit，可以存储 0 或 1
  * 字节 byte， 1 byte = 8 bit。1个8位的字节有256种可能的0、1组合
  * 字(字长) word，与使用的电脑有关。64位的操作系统，1个word = 64 bit
* int：有符号整型。存储一个int要占用一个机器字长
  * 声明int变量：可以一次一个，也可以一次多个
  * 变量获取值有3种方法
    * 赋值
    * 通过函数(如 scanf) 获得值
    * 初始化变量
  * 初始化变量即在变量声明的同时赋值。最好是一次一个，否则容易引起误解
  * 如果以十进制显示数字，使用%d；以八进制显示数字，使用 %o；以十六进制显示数字，使用%x
* short int（或者简写为short）常用于较小数值的场合以节省空间。有符号
* long int （或者简写为 long）适用于较大数值的场合。有符号
* long long int （ long long）至少占64位。有符号
* unsigned int （unsigned）只用于非负值的场合

* 现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。

* 整数溢出时会重新从起始点开始。unsigned int 从0开始，int从负数开始

* 打印 unsigned int，使用%u；打印long，使用%ld( %lo, %lx)

* 打印short，使用 %hd( %do, %hx)

* char 类型用于储存字符，==是整数类型==，实际存储的是整数而不是字符。计算机使用数字编码来处理字符。在printf中使用 %c打印

* C语言把1 byte(8 bit)定义为 char 类型占用的位数

* 在C语言中，==单引号==括起的==单个字符==被称为字符常量，如果单引号内有多个字符会报错。**字符类型与字符串类型不同**

* 为字符类型的变量赋值可以使用字符常量，也可以用相应的ASCII码

  * 输出字符还是数值代码与 %c 和%d有关

  * int a 与 char a 区别仅在于占用的内存长度不同，char 是最小的整型
  * 如果确实是要输出字符类型，还是使用char，既明确又减少占用

* 代表行为的字符（如退格、换行等）表示方法：
  * 使用ASCII码
  * 使用转义序列
  
* printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式
  * printf("%c", grade); 输出grade的字符显示
  * printf("%d", grade);输出grade的整数表示
  
* 通常，系统储存一个浮点数float要占用32位。其中8位用于表示指数( e后面的部分 )的值和符号，剩下24位用于表示非指数( e前面的 )部分（也叫作尾数或有效数）及其符号。
  * e或E可以省略，如3.14159
  * 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。
  * 可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。
  * 不要在浮点型常量中间加空格
  
* double占用64位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。

* 通常情况下compiler会假定浮点型常量是double类型，使用双精度进行运算，然后截断成float类型的宽度。这样做的计算精度高，但是会减慢程序的运行速度

* 在浮点数后面加上 f 或 F 后缀可以覆盖默认设置，提高运行速度

* printf() 函数使用%f 打印==十进制的float 和 double 类型浮点数==，用 %e 打印指数计数法的十进制浮点数

* 如果系统支持十六进制格式的浮点数，可以用%a 输出指数计数法的十六进制浮点数

* C语言中有3种复数类型：
  * float_Complex
  * double_Complex
  * long double_Complex
  
* 3种虚数类型：
  * float_Imaginary
  * double_Imaginary
  * long double_Imaginary
  
* 如果包含 complex.h 头文件，可以使用 complex代替_Complex，用imaginary代替 _Imaginary，还可以用 I 代替 -1的平方根

* 类型大小：sizeof() 函数
  
  * 注意，要使用 %zd 匹配 sizeof() 的返回值
  
* 关键是要理解无论双引号中包含多少个字符和标点符号，==一个字符串就是一个参数。==
  * 区分 char 和 string！！！！！
  * ==char 是最小的整数类型==，只有1 byte
  
* C 语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。程序要知道函数的参数个数才能正常工作。printf()和scanf()函数用第1个参数表明后续有多少个参数，即==第1个字符串中的转换说明与后面的参数一一对应==。
  
* printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。

* C 标准明确规定了何时把缓冲区中的内容发送到屏幕：
  * 缓冲区满
  * 遇到换行字符
  * 需要输入的时候
  
* 从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区

* 还有一种刷新缓冲区的方法是使用fflush()函数



# 第四章 字符串和格式化输入 / 输出

* 字符串：使用数组存储的一组 char 变量，一个或多个字符的序列
* C语言中 双引号与单引号是必须区分的

```c
   // talkkback.c -- 演示与用户交互

   #include <stdio.h>
   #include <string.h>   // 提供 strlen() 函数的原型
   #define DENSITY 62.4  // 人体密度 (单位：磅 / 立方英尺)

   int main()
   {
       float weight,volume;
       int size,letters;
       char name[40];         // name 是一个可容纳 40 个字符的数组
       printf("Hi! What's your first name?\n");
       scanf("%s", name);
       printf("%s, What's your weight in pounds?\n", name);
       scanf("%f", &weight);
       size = sizeof name;
       letters = strlen(name);
       volume = weight / DENSITY;
       printf("Well, %s, your volume is %2.2f cubic feet.\n", name, volume);
       printf("Also, your first name has %d letters,\n", letters);
       printf("and we have %d bytes to store it.\n", size);
    // printf("%c", name[0]);
       return 0;
   }
```

* 上面的程序里，scanf() 中 name没有&前缀，而 weight 有。此处 &weight 和 name 都是地址
* #是一条C预处理指令
* strlen()可以获取字符串的长度
* C语言中用空字符 \0 标记字符串的结束。空字符不是数字 0，它是非空打印字符
* 由于C中的字符串一定以空字符结束，这意味着==数组的容量必须至少比待存储字符串中的字符数多1==。
* 什么是数组？
  * 数组是同类型数据元素的有序序列
* char name[40];
  * name 后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的元素数( 字符串中会少1 )。char 表明每个元素的类型
* scanf() 在遇到第 1 个空白时就不再读取输入。一般而言，scanf只会读取字符串中的一个单词，而不是一整句。
* 可使用fgets() 读取一般字符串
* 字符串常量"x"和字符常量'x'不同。
  *  区别之一在于'x'是基本类型（char） ， 而"x"是派生类型（char数组） ；
  *  区别之二是"x"实际上由两个字符组成： 'x'和空字符\0  
* sizeof() 函数以字节为单位给出对象的大小，返回类型为 %zd。这里的对象大小指整个变量占用的内存空间
* strlen() 给出字符串中的字符长度，遇到空字符'\0' 后就不再记录，因此strlen得到的结果小于等于sizeof。返回结果通常是unsigned或unsigned long。
* 处理长 printf() 语句的两种方法：
  * 将 printf() 语句在参数之间( 逗号之后 ) 分为两行。
  * 使用两个 printf()，只在第2个printf中使用换行符
* 定义符号常量的方法：
  * 预处理，#define name value
  * 使用 const type name value



```c
/* praise1.c -- 使用不用类型的字符串 */
#include <stdio.h>
#define PRAISE "You are an extraordinary being."
int main(void)
{
    char name[40];
    printf("What's your name?");
    scanf("%s", name);
    printf("Hello, %s, %s\n", name, PRAISE);
    return 0;
}
```

* scanf() 只读取了 Meng Zixuan 中的 Meng，它在遇到第一个空白 (空格、制表符或换行符)  时就不再读取输入。

* 一般而言，根据 %s 转换说明，scanf() 只会读取字符串中的一个单词，而不是一整句。C 语言还有其他的输入函数 ( 如，fgets() )，用于读取一般字符串。

* 字符串常量 " x " 和 字符常量 ' x ' 不同。

  * 区别之一在于：' x ' 时是基本类型 char，而 " x " 是派生类型 char数组
  * 区别之二在于：" x " 实际上由两个字符组成：' x ' 和空字符 \0

* sizeof 运算符：以字节为单位给出对象的大小

* strlen() 函数给出字符串中的字符长度

* 1字节存储一个字符，但两种方法应用于字符串得到的结果并不相同

* strlen() 只记录字符串中空字符 \0 以前的长度，sizeof 则计算字符串中的全部字符，因此 sizeof 给出的数不小于 strlen 

* C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了 %zd 转换说明，这对于 strlen() 同样适用

* sizeof 是否使用圆括号取决于运算对象是类型还是变量

  * 对于类型，必须写成 sizeof(char)，sizeof(float)
  * 对于变量，可以写成 sizeof name 或者 sizeof 6.28

* 为方便起见，建议所有情况下都使用圆括号 sizeof(6.28)

* 预处理定义的常量也成为明示常量( manifest constant )

  * 通用格式：#define NAME value

* C90 标准新增了 const 关键字，用于限定一个变量为只读：

  ```c
      const int MONTHs = 12; // MONTHS 在程序中不可更改，值为12
  ```

* 这使得 MONTHS 成为一个只读值，const使用起来比 #define 更灵活

* 在转义字符 %f 或%d 中可以指定输出的数据宽度

  * %4.2f 输出字符宽度为4的浮点数，其中小数点后有两位数字。
  * %10.3E 输出字符宽度为10的指数浮点数，其中尾数部分的小数点右侧有3位有效数字
  * [%24.5s] 输出字符宽度为24的字符串，.5限制了待打印的字符个数为5个字符
  * %.3 自动分配恰好打印的字符宽度，小数点有效数字为3或打印3个字符

* 转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。

* printf()函数也有一个返回值，它返回打印字符的个数。

* printf函数的语句太长在屏幕上不方便阅读时，可以把一条语句写成多行。

* 如果用 scanf() 读取基本变量类型的值，在变量名前加上一个 &；

* 如果用 scanf() 把字符串读入字符数组中，不需要使用&

  * 只是在scanf中对数组不用加&

* scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符(如逗号,)必须与输入字符串严格匹配。

* 在C语言中scanf()并不是最常用的输入函数，但它可以读取不同类型的数据

* scanf()函数返回成功读取的项数。

* printf()和scanf()都可以使用*修饰符来修改转换说明的含义。

* printf() 中的*用于代替字段宽度和精度，需要在参数中告诉函数它的值。( 相当于占位符中的占位符 )

* scanf中的 * 用于跳过相应的输出项。

* 想把数据打印成列，指定固定字段宽度很有用。  

* 另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适， 没有不必要的空白。   



# 第五章 运算符、表达式和语句

## 循环

* 循环(loop)，while循环，for循环。计算机最擅长重复计算

## 基本运算符

* 赋值运算符：= 赋值行为从右往左进行，左侧必须引用一个存储位置。

  * 用于储存值的数据存储区域统称为数据对象(data object)。在C语言中的术语为可修改的左值(modifiable lvalue)或对象定位值(object locator value)

  * C 语言支持连续赋值(Python也是)：

    ```c
    a = b = c =5
    //a,b,c的值都是5
    ```

* 加法运算符：+

* 减法运算符：-   

  *  \+ 和 - 运算符都被称为二元运算符(binary operator)，需要两个运算对象才能完成操作
  * 减号还可用于标明或改变一个值的代数符号，此时的 - 被称为一元运算符

* 乘法运算符：*

* 除法运算符：/

  * 整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数进行除法的结果是整数，其商的小数部分被丢弃。这一过程被称为截断(trucation)
  * 尽量避免使用混合类型。混合整数和浮点数计算的结果是浮点数。
  * C99标准规定采用“趋零截断”的舍入方法，既直接丢弃小数部分

* 运算符优先级

  * 先执行高优先级的运算符，再执行低优先级的运算符
  * 相同优先级的运算符一般按从左到右的顺序进行(=运算符除外)
  * 可以使用圆括号来更改执行的顺序

* 当运算符共享一个运算对象时，优先级决定了求值顺序。结合律只适用于共享同一运算对象运算符

## 其他运算符

* sizeof 运算符和size_t类型

  * sizeof运算符以字节为单位返回运算对象的大小。如果运算对象是类型，则必须用圆括号将其括起来
  * C 语言规定，sizeof返回size_t类型的值。size_t是一个无符号整数类型，但并非新类型。size_t是语言定义的标准类型。C 有一个typedef机制，允许程序员为现有类型创建别名。
  * typedef double real;
  * 这样，real就是double的别名。可以声明一个real类型的变量；
  * real deal; // 编译器查看real时会发现，在typedef声明中，real已经成为double的别名，于是把deal创建为double类型的变量。
  * 类似的，在C的头文件系统中可以使用typedef把size_t作为unsigned int或unsigned long的别名。 
  * C99新增了 %zd 转换说明用于printf()显示 size_t类型的值
* 求模运算符： %
  * 只能用于**整数**运算，给出其左侧整数除以右侧整数的余数
  * 常用于控制程序流
  * 负数求模如何运行？
    * 如果第一个对算对象(被除数)是负数，那么求模的结果为负数；如果第一个对算对象是正数，那么求模的结果也是正数
    * 无论何种情况，只要 $a$ 和 $b$ 都是整数值，就可以通过$a-\frac{a}{b}\times b$ 来计算 $a \% b$ 
* 递增运算符：++
  * 有前缀模式和后缀模式，区别在于递增行为发生的时间不同。前缀模式先递增后使用，后缀模式先使用后递增。
    * 单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。
  * 把变量的递增过程放入 while循环的条件中，这种结构在 C 语言中很普遍
  * 好处：使得程序更加简洁，把控制循环的两个过程集中在一个地方，不会忘记更新循环
* 递减运算符：--
* 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。
* 递增和递减运算符只能影响一个变量（一个可修改的左值）
  * (x*y)++    这种写法是无效的
* 在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。
  * 遵循的原则：
    * 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；
    * 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。

## 表达式和语句

* C 表达式由运算符和运算对象组成。它的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作
* 有赋值运算符的表达式的值与赋值运算符的左侧变量的值相同
  * q = 5 * 2作为一个整体的值是10。
  * 3 > 2 的值为 1。
  * 6 + (c = 3 + 8) 的值为 17。
* 在C语言中任何表达式加上分号 ； 都可以看作是一条语句。如果不加分号 ；只能是一个表达式。
* 真正有用的语句是指改变值或者调用函数的表达式
* C语言术语：**副作用(side effect)**
  * 副作用是对数据对象或文件的修改
  * states = 50; 的副作用是将变量的值设置为50
* 从C语言的角度看，主要目的是对表达式求值，而程序员的主要目的可能是使用其副作用
* 类似地，调用 printf()函数时，它显示的信息其实是副作用。printf()的返回值是待显示字符的个数）

* 序列点(sequence point)是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在C语言中，**语句中的分号标记了一个序列点**

  * 在一个语句中，运算符对运算对象做的改变(副作用)**必须在程序执行下一条语句之前完成**

  * **任何一个完整表达式的结束也是一个序列点**

  * 序列点有助于分析后缀递增何时发生

    ```c
    while (guests++ < 10)
        printf("%d \n", guests);
    ```

  * 表达式guests++ < 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）。同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。

* 复合语句(compound statement)是指用花括号括起来的一条或多条语句

  * 在C语言中，缩进对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。

## 类型转换

* 类型升级通常不会有什么问题，但是类型降级会导致真正的麻烦
* 强制类型转换运算符(cast operator)：圆括号和它括起来的类型名
  * （type） 将其右侧的值转换成圆括号中指定的类型



## 带参数的函数

* 如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。
* 如果函数接受一个 int 类型的参数，则圆括号中包含一个int类型变量的
  声明。**其他非int类型的变量传入时会被强制转换程int类型的变量**
* 在英文中，argument和parameter经常可以互换使用，但是C99标准规定实参(函数调用时的参数)使用术语argument；形参(函数声明时的参数)使用术语parameter



## 关键概念

* C 通过运算符提供多种操作，运算符和运算对象组成了表达式。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。
* **每个C表达式都有一个值。**即使是赋值表达式
* 不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。



# 第六章 C控制语句：循环

**3种程序流**：

         1. 顺序执行
            2. 循环执行
            3. 分支执行

## while(不确定循环)

* while语句创建了一个循环，重复执行直到测试表达式为假或0。

* while语句是一种**入口条件循环**，也就是说，在执行多次循环之前已决定是否执行循环。因此，循环有可能不被执行。

* 循环体可以是简单语句，也可以是复合语句。

* scanf("", &) 函数如果成功读入符合声明类型的数据，会返回读入数据个个数

* 如果没有读入符合声明类型的数据，那么scanf的返回值就是0

* 利用scanf的上述特性可以直接将其作为while循环的循环判断条件

* 通用形式：

  * while (expression){

    ​    statement

    }

* 终止while循环：
  * 让expression的值有变化，最终为假
  * expression值不变，是死循环，用break和if语句来终止
* 使用while时，要牢记一点：只有在测试条件后面的单独语句即statement部分才是循环内容
  * 如果不加 { } 则statement只是紧跟while的下面一行语句
* 关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关系表达式。
* 关系表达式可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，**不能用关系运算符比较字符串**
* 比较浮点数相等时尽量用**两者的差小于某个很小的数**来代替，因为计算机中的浮点数都是不准确的

* 只要 expression 的值是非0的，就认为是True
* 多用while(goats) 而不是 while(goats != 0)

### _Bool 类型变量

* \_Bool类型的变量只能储存1（真）或0（假）。如果把其他非零数值赋给\_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。

### 真值的问题

* 如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。
* 不要在本应使用 == 的地方使用 = 

## for(计数循环)

* 在创建一个重复执行固定次数的循环中涉及了3个行为：
  1.必须初始化计数器；
  2.计数器与有限的值作比较；
  3.每次循环时递增计数器。

* for循环把上述3个行为（初始化、测试和更新）组合在一处。

* 通用形式：

  * for( expression1 ; expression2 ; expression3 ){

    ​    statement

    }

  * 关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。

    * 第1个表达式是初始化，只会在for循环开始时执行一次。
    * 第2个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假，则循环结束。
    * 第3个表达式执行更新，在每次循环结束时求值。

  * for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。

* 可以省略一个或多个控制表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。

* for语句是一种**入口条件循环**，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。

## 逗号运算符

**逗号也可用作一种运算符**

* 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。

* 逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。
* 逗号是一个序列点，逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生，它保证了被它分隔的表达式从左往右求值
* 整个逗号表达式的值是右侧项的值

逗号也可用作分隔符

## do while(出口条件循环)

* 通用形式：

  * do 

  ​      statement

  ​    while ( );

* do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次。适用于那些至少要迭代一次的循环

## 如何选择循环

* 如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条
  件循环。通常，入口条件循环用得比较多，有几个原因。

  * 其一，一般原则是在执行循环之前测试条件比较好。
  * 其二，测试放在循环的开头，程序的可读性更高。
  * 另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。

* 那么，假设需要一个入口条件循环，用for循环还是while循环？

  * 这取决于个人喜好，因为二者皆可。

  * 要让for循环看起来像while循环，可以省略第1个和第3个表达式。

    * for(;test;)
    * while(test)   // 两者效果相同

  * 要让while循环看起来像for循环，可以在while循环的前面初始化变量，并在while循环体中包含更新语句。

    * 初始化；

    ​    while( test )

    ​    {

    ​        statement

    ​        update

    ​    }

    * for(初始化; test; update)

      {

      

      }  //两者效果相同

## 嵌套循环(nested loop)

* 嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。
* 嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。



## 数组简介

* 数组可以作为一种储存多个相关项的便利方式。循环经常用到数组
* 数组（array）是**按顺序储存**的**一系列类型相同的值**，如10个char类型的字符或15个int类型的值。
* 整个数组有一个数组名，通过整数下标访问数组中单独的项或元素（element）。
  * 注意，数组元素的编号从0开始，不是从1开始。可以给每个元素赋float类型的值。
  * 实际上，使用数组元素和使用同类型的变量一样。
  * 这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。
  * 数组的类型可以是任意数据类型。
* 字符串：
  * 可以把字符串储存在 char 类型的数组中。如果 char 类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

![image-20201127120447550](note%20for%20C.assets/image-20201127120447550.png)

* 用于识别数组元素的数字被称为下标（subscript）、索引（indice）或偏移量（offset）。
* 下标必须是整数，而且要从0开始计数。
* 数组的元素被依次储存在内存中相邻的位置
* 声明格式：
  * type name[size]
  * 最终name能取到的下标是 size - 1，其长度为size，从0开始取



### 在 for 循环中使用数组

```c
#include <stdio.h>
#define SIZE 10
#define PAR 72

int main(void){
	int index, score[SIZE];
	int sum = 0;
	float average;
	printf("Enter %d golf scores:\n", SIZE);
	for(index = 0; index < SIZE; index++)
	    scanf("%d", &score[index]);
	printf("The scores read in are as follows:\n");
	for(index = 0; index < SIZE; index++)
	    printf("%5d", score[index]);    //验证输入
	printf("\n");
	for(index = 0; index < SIZE; index++)
	    sum += score[index];
	average = (float)sum / SIZE;
	printf("Sum of scores = %d, average = %.2f\n", sum, average);
	printf("That's a handicap of %.0f.\n", average - PAR);	
	return 0;
}
```

* 由于`scanf()`会跳过空白字符，所以可以在一行输入10个数字，也可以每行只输入一个数字，或者像本例这样混合使用空格和换行符隔开每个数字
* 该程序示例演示了一些较好的编程风格。
  * 第一，用`#define`指令创建的明示常量（SIZE）来指定数组的大小。
  * 第二，下面的代码可以很方便地处理一个大小为`SIZE`的数组：
    * ` for (index = 0; index < SIZE; index++)`
  * 第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确保程序处理的数据与期望相符。

## 使用函数返回值的循环

* 编写一个有返回值的函数，要完成以下内容：
   1.定义函数时，确定函数的返回类型；
   2.使用关键字return表明待返回的值。
* 要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 return 表明该函数将把它后面的值返回给主调函数。
  * 返回值也可以是表达式的值

* 如果把函数的定义置于main()的文件顶部，就可以省略前置声明
* 但是，这不是C的标准风格。因为main()通常只提供整个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。



# 第七章 C控制语句：分支和跳转

## if 语句

* if 语句的通用形式：

​				if ( expression )

​				statement

* 如果对 expression 求值为真 ( 非 0 )，则执行 statement；否则，跳过 statement。与while循环一样，statement可以是一条简单语句或复合语句。
* 如果statement是一条简单语句，则直接在if 的下一行写完加上分号即可；如果是复杂语句，需要用花括号括起形成一段语句块==即使if语句由复合语句构成，整个if语句仍被视为一条语句。==
* if 语句的结构和 while 语句很相似，它们的主要区别是：如果满足条件可执行的话，if 语句只能测试和执行一次，而 while 语句可以测试和执行多次

## if else 语句

* if 和 else 之间只允许一条语句( 简单语句或复合语句 )，因此如果要在 if 和 else 之间执行多条语句，必须用花括号把这些语句括起来成为一个块



## getchar() 和 putchar()

* 字符输入输出函数：
  * getchar()
  * putchar()

* getchar()函数不带任何参数，它从输入队列中返回下一个字符。

* putchar()函数打印它的参数。

* 由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。
* 注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件中

* 示例程序:如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符。

```c
// cypher1.c -- 更改输入，空格不变
#include <stdio.h>
#define SPACE ' '　　　　　　　 // SPACE表示单引号-空格-单引号
int main(void){
    char ch;
    ch = getchar();　　　　　　 // 读取一个字符
    while (ch != '\n'){　　　　 // 当一行未结束时
        if (ch == SPACE)　　　 // 留下空格
            putchar(ch);　　　 // 该字符不变
        else
            putchar(ch + 1);　 // 改变其他字符
            ch = getchar();　　　　// 获取下一个字符
    }
    putchar(ch);　　　　　　　　// 打印换行符
    return 0;
}    
```

* 使用输入项的值来判断是否结束循环。

* ctype.h 提供了一个 isalpha()函数来判断实参是否为一个字母。
* 还提供了tolower(), toupper()来返回实参的小写, 大写（不改变原始参数）

![image-20201127125811096](note%20for%20C.assets/image-20201127125811096.png)

```c
// cypher2.c -- 替换输入的字母，非字母字符保持不变
#include <stdio.h>
#include <ctype.h>

int main(void){
    char ch;
    while((ch = getchar()) != '\n'){
        if(isalpha(ch))   //如果是一个字符
            putchar(ch + 1); //显示该字符的下一个字符
        else
            putchar(ch); // 原样显示
    }
    putchar(ch);    // 显示换行符
    return 0;
}
```



## 多重选择 else if

* else if 是已学过的 if else 语句的变式。
* else 与 if 配对
  * 规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来

![image-20201127130410999](note%20for%20C.assets/image-20201127130410999.png)



## 逻辑运算符

* 如果导入了<stdbool.h>，则可以用bool 类型替换\_Bool类型
* 有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。
* 这种情况下可以使用逻辑运算符(或||且&&非！)，并使用句点（.）标识句子的末尾。

* 导入<ios646.h>后可以用 and代替&&，or代替||，not代替！

## 一个统计单词的程序

* 该程序读取并报告单词的数量，还可以计算字符数和行数

  * 要逐个字符读取输入，知道何时停止读取
  * 能识别并计算这些内容：字符、行数和单词

  pseudo_code: 

  ```pseudocode
  读取一个字符
  当有更多输入时：
      递增字符计数
  如果读完一行
      递增行数计数
  度过读完一个单词
      递增单词计数
  读取下一个字符
  输入的循环模型：
  while((ch = getchar()) != stop)
  {
  ...
  }
  ```

  

* stop表示能表示输入末尾的某个值，选用|

## 条件运算符：？

* C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式该表达式使用?:条件运算符。
* 该运算符分为两部分，需要3个运算对象，称为三元运算符。
* 条件运算符是C语言中唯一的三元运算符

​       `x=(y < 0)? -y:y;`

* 在 = 和 ; 之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x = -y;否则，x = y”。
* 用if else可以这样表达：

```c
if(y < 0)
    x = -y;
else
    x = y;
```

* 条件表达式的通用形式如下：
  * expression1 ? expression2 : expression3
* 如果 expression1 为真（非0），那么整个条件表达式的值与expression2的值相同
* 如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。

* 通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。

## 循环辅助：continue 和 break

### continue 语句

* 3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。
  * 对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值。
  * 对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
* 如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。

### break语句

* 程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。

* 如果break语句位于嵌套循环内，它只会影响包含它的当前循环。

![image-20201127161236364](note%20for%20C.assets/image-20201127161236364.png)

* break还可用于因其他原因退出循环的情况。

* 在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。
* 嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break：



## 多重选择：switch 和 break

* 使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if...else来完成。但是，大多数情况下使用switch语句更方便。

* switch (expression){ // 表达式的值必须是一个整数值，包括char

  ​    case 1:

  ​        statement_1

  ​        break;

  ​    ...

  ​    case n:

  ​        statement_n 

  ​        break;

  ​    default:        //可选

  ​        statement_n+1

  }

* 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
* expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。

![image-20201127164937558](note%20for%20C.assets/image-20201127164937558.png)

## goto语句(程序跳转)

* break和continue是goto的特殊形式。
* C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）



## 关键概念

* 要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符(或且非)把两个完整的测试表达式组合起来。



# 第八章 字符输入/输出和输入验证

## 单字符I/O：getchar()和putchar()

* getchar()和 putchar()每次只处理一个字符，要处理多个字符时可以使用while循环语句

## 缓冲区

* 大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。
* 用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。

![image-20201127200957328](note%20for%20C.assets/image-20201127200957328.png)

## 结束键盘输入

* 从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。
* 计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。
* 操作系统使用的另一种方法是储存文件大小的信息。
* 如果文件有3000字节，程序在读到3000字节时便达到文件的末尾
* 无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：
  * #define EOF (-1)


* 为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。
* 无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。
* 这里关键要理解**EOF是一个值**，标志着检测到文件结尾，并不是在文件中找得到的符号。

```c
/* echo_eof.c -- 重复输入，直到文件结尾 */
#include <stdio.h>
int main(void){
    int ch;
    while ((ch = getchar()) != EOF)
        putchar(ch);
    return 0;
}
```











# 第九章 函数

* 函数功能：1、执行某些动作，如printf() 把数据打印到屏幕上

​				           2、找出一个值供程序使用，如strlen() 把指定字符串的长度返回给程序

​                          3、改变内存的值，使用指针进行通信

* 描述性的函数名能清楚地表达函数的用途和组织结构。然后单独设计和测试每个函数，直到函数都能正常完成任务。在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系

* 了解函数：正确地定义函数、调用函数、建立函数间的通信

* 通常用户要使用自己定义的函数user_function需要在3处使用user_function标识符：首先声明函数原型，一般在main函数之前，告诉compiler user_function返回值的类型和函数接受的参数类型，==这些信息称为该函数的签名( signature)==；然后是函数调用，一般在main 函数之内，表明在此处执行函数；最后是函数定义，明确定义函数要做什么

* 注意：声明函数原型要带分号，定义函数不带分号且要用花括号

* ==任何函数和变量在使用之前都要声明该函数或的类型==

* 下面以具体的程序为例进行说明

  ```c
  /* lethead1.c*/
  
  #include <stdio.h>
  #define NAME "GIGTHINK, INC."
  #define ADDRESS "101 Megabuck Plaza"
  #define PLACE "Megapolis, CA 94904"
  #define WIDTH 40
  
  void starbar(void); /*函数原型。注意必须先在主函数之前声明要用到的函数名，然后在主函数之后具体定义此函数*/
  
  int main(void){
      starbar();
      putchar('\n');
      printf("%s\n", NAME);
      printf("%s\n", ADDRESS);
      printf("%s\n", PLACE);
      starbar();     /*使用函数*/
      return 0;
  }
  
  void starbar(void){   /*定义函数*/
      int count;
      for (count = 1; count <= WIDTH; count++)
      {
          putchar('*');
      }
      
  }  
  ```

* void starbar(void);

  * 圆括号表明starbar是一个函数名
  * 第一个void是函数类型，void类型表明没有返回值
  * 第二个void表明该函数不带参数
  * ==分号表明这是在声明函数，不是在定义函数==，告诉compiler在别处查找该函数的定义
  * 有一些老版本的编译器甚至识别不了 void，如果必须使用这种编译器，可以把没有返回值的函数声明为 int 类型
  * 对于starbar函数而且，该函数没有返回值，没有参数
  * 声明函数原型一般在main函数之前，也可以在main函数之后

* starbar();

  * 这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling  function）继续执行下一行
  * starbar()函数中的变量count是局部变量（local  variable），意思是该变量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用count，这不会引起名称冲突，它们是同名的不同变量。

* starbar() 函数只能打印星号，且只能打印40个，并不美观。这是因为starbar()函数没有用函数参数，因此编写show_n_char(chartype, number) 函数来控制要打印的字符类型与个数

  ```c
  /* lethead2.c*/
  
  #include <stdio.h>
  #include <string.h>    /* 为 strlen() 提供原型*/
  #define NAME "GIGATHINK, INC."
  #define ADDRESS "101 Megabuck Plaza"
  #define PLACE "Megapolis, CA 94904"
  #define WIDTH 40
  #define SPACE ' '
  
  void show_n_char(char ch, int num);
  int main(void){
      int spaces;
      show_n_char('*', WIDTH);   /*用符号常量作为参数*/
      putchar('\n');
      show_n_char(SPACE,12);       /*用符号常量作为参数*/
      printf("%s\n", NAME);
      spaces = (WIDTH - strlen(ADDRESS)) / 2;    /*计算要跳过多少个空格*/
      show_n_char(SPACE, spaces);  /*用一个变量作为参数*/
      printf("%s\n", ADDRESS);
      show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
      printf("%s\n", PLACE);       /*用一个表达式作为参数*/ 
      show_n_char('*', WIDTH);
      putchar('\n');
      return 0;
  }
  
  /*show_n_char() 函数的定义*/
  void show_n_char(char ch, int num){
      int count;
      for (count = 1; count <= num; count ++)
      putchar(ch);
  }
  ```

* void show_n_char(char ch, int num)；

  * 该行告知compiler函数使用两个参数 ch 和 num，ch 是 char 类型，num 是 int 类型。在圆括号内定义的这两个变量称为形式参数( formal argument, 形参)。与定义在函数中的变量一样，形参也是局部变量，每次调用函数，必须给这些变量赋值，实际参数( actual argument, 实参) 提供了赋给形参的值。
  * 该行末尾的分号表明此处是声明函数。在声明函数时圆括号内可以只写形参的类型，无需写具体的形参名==在函数定义时则必须写明==
  * 形参的定义必须在每个变量前都声明，即使他们是同一个类型。这一点与普通变量声明时不同
  * 实际参数是出现在函数调用时圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。实际参数可以是常量、变量，或甚至是更复杂的表达式。==无论实际参数是何种形式都要求值==
  * 局部变量的好处是将不同的函数隔离开，彼此相当于黑盒，互不影响

* 在主函数中通过实参 -> 形参把主函数中的值传递到子函数中，而子函数可以使用return将子函数中的值传回主函数

  ```c
  /* lesser.c -- 找出两个整数中较小的一个*/
  #include <stdio.h>
  int imin(int, int);
  
  int main(void){
      int evil1, evil2;
      printf("Enter a pair of integers (q to quit):\n");
      while (scanf("%d %d", &evil1, &evil2) == 2){
          printf("The lesser of %d and %d is %d.\n", evil1, evil2, imin(evil1, evil2));
          printf("Enter a pair of integers (q to quit):\n");
      }
      printf("Bye.\n");
      return 0;
  }
  int imin(int n, int m){
      int min;
      if (n < m)
      min = n;
      else
      min = m;
      return min;
  }
  ```

* 可以直接使用 return；语句结束main函数，没有返回值。只能使用在 void 类型的函数中

* ==要正确地使用函数，程序在第一次使用函数之前必须知道函数的签名.==通常的做法是提前声明函数，把函数的签名提前告知compiler

* sqrt() 函数的代码在math.h 文件中，在调用之前要先声明 double sqrt( double )

* 当float类型被作为参数传递时会被升级为double类型

* 在我们的系统中，两个double类型的值就是两个64位的值, 每个int类型的变量占用32位

* 调用函数时会==先根据实参==向栈中存入相应位数的值，然后==再由形参==向栈中读取相应位数的值。如果实参与形参的类型不一致，那么调用函数时读取到的参数(形参的位数)就会与实参不同，进而出错

* 函数声明时( 带分号 )定义的变量名是假名，与函数定义时( 带花括号 )定义的不必相同，因此函数声明时可以只给出变量的类型与个数，等函数定义时再具体定义变量名，并且此变量为局部变量

* printf() 函数中的第一个参数是一个字符串，而==其他的参数类型与数量都要根据字符串参数来确定==

  * printf("%d  %d  %.2f  %s", a, b, c, d)
  * 根据第一个参数"%d  %d  %.2f  %s"可知后面还有4个类型分别为整型、整型、浮点型、字符串型的参数
  * C语言里函数的参数( 圆括号内的变量 )都是用逗号隔开的

* 如果函数比较简单，可以将函数声明略去，直接再main函数之前定义函数。

* 总之必须牢记：==要正确地使用函数，程序在第一次使用函数之前必须知道函数的签名.==

* 递归 recursion

  * 函数调用函数本身，难点在于递归的结束
  * 可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。
  
  * 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。
  * 一般而言选择循环比较好。递归使用的内存多、执行速度慢。递归不方便阅读和维护
  * 递归在处理倒序时非常方便
  
* 递归的几个要点

  * 每级函数调用都有自己的变量。虽然它们的变量名可能相同，但地址不同（相当于每次递归调用都会创建各自的独立变量）
  * 每次函数调用完毕都会返回一次上一级递归。递归调用是层层嵌套的，程序必须按顺序逐级返回递归
  * 递归函数中位于递归调用之前的语句，均按被调函数的顺序执行
  * 递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用
  * 虽然每级递归都有自己的变量，但是并没有复制代码，每次递归相当于又从头开始执行原来写好的代码。除了为每次递归调用创建新的局部变量之外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替
  * 递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用 if 或其他等价的测试条件在函数形参等于某特定值时终止递归。==为此，每次递归调用的形参都要使用不同的值==

* 递归和倒序计算

  * 当处理倒序问题时，递归比循环简单
  * 问题：编写一个函数，打印一个整数的二进制数
  * 一般而言，对于数字 n，其二进制的最后一位是 n % 2，计算的第一位数字实际上是带输出二进制数的最后一位==在递归函数的递归调用之前计算 n % 2，在递归调用之后打印计算结果==。这样，计算的第1个值正好是最后一个打印的值。
  * 要获得下一位数字，就必须把原数整除2，再将商对2取取余数。举例来说，5 % 2 = 1，第一位是1；5 / 2 = 2，2 % 2 = 0，第二位是0；2 / 2 = 1，1 % 2 = 1，第三位是1；==停止条件：与2相除（整除以2）的结果小于2时停止==，因此 5 的二进制数就是 101
  * putchar() 中只能输入 ' '，不能用 " "
  * 在C语言中，可以通过\n来控制不同的printf函数输出是否在同一行，不带\n 则将会与下一个printf在同一行。==同一行的输出可以由多个printf组成==

* 递归创建斐波那契数列

  ```c
  unsigned　long　Fibonacci(unsigned　n)
  {
  if　(n　>　2)
  return　Fibonacci(n-1)　+　Fibonacci(n-2);
  else
  return　1;
  }
  ```

  * 该函数使用了双递归（double recursion），即函数每一级递归都要调用本身两次。
  * 由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！
  * 在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。
  * ==在程序中使用递归要特别注意，尤其是效率优先的程序。==

* 所有的C函数皆平等

  * 程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。

* 把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。

# 第十章 数组



# 第十一章 字符串和字符串函数





# 第十四章 结构和其他数据形式

## 实例问题：创建图书目录

* 打印图书目录，需要一种既能包含字符串，又能包含数字的数据形式，而且还要保持各信息的独立

* 如果用多个不同的数组分别记录图书目录的每一项则比较繁琐

* C语言中的结构变量(structure variable)就满足了这种情况下的需求

  * 声明格式：

  ​        struct name

  ​       {

  

  ​        };  // 创建了一个name类型的结构体变量

  * 使用格式：struct name var1; // 把var1声明为一个book类型的变量6

    ```c
/* book.c -- 一本书的图书目录 */
#include <stdio.h>
#include <string.g>

char *s_gets(char *st, int n);
#define MAXTITL 41  /* 书名的最大长度 +1*/
#define MAXAUTL 31  /* 作者姓名的最大长度 +1 */
struct book{
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};
    ```

