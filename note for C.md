

# 第一章

* C 编译器负责把C代码翻译成特定的机器语言。此外，C编译器还将源代码与C库（库中包含大量的标准函数供用户使用，如`printf()`和`scanf()`）的代码合并成最终的程序（更精
  确地说，应该是由一个被称为链接器的程序来链接库函数，但是在大多数系
  统中，编译器运行链接器）。
* 其结果是，生成一个用户可以运行的可执行文件，其中包含着计算机能理解的代码。



## 目标代码文件、可执行文件和库

* C编程的基本策略是，用程序把源代码文件转换为可执行文件（其中包含可直接运行的机器语言代码）。
* 典型的C实现通过**编译**和**链接**两个步骤来完成这一过程。
* **编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件。**
* C 使用这种分而治之的方法方便对程序进行模块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。
* 另外，链接器还将你编写的程序和预编译的库代码合并。

![image-20201228214316027](./note for C.assets/image-20201228214316027.png)

* 目标文件中只包含编译器为你编写的代码翻译的机器语言代码
* 可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码，它们通过链接器组合在一起。
* 启动代码充当着**程序和操作系统之间的接口**。例如，可以在MS Windows或Linux系统下运行IBM PC兼容机。这两种情况所使用的硬件相同，所以目标代码相同，但是Windows和Linux所需的启动代码不同，因为这些系统处理程序的方式不同。

# 第二章

* 程序的输出在屏幕上一闪而过，可以在 `return` 语句前添加 `getchar()`

* `#include`: 预处理器指令

* 头文件中可以定义一些常量，或者声明函数名，==但是函数的实际代码在一个预编译代码的库文件中==
  
* 头文件帮助compiler把你的程序正确地组合在一起
  
* `main()` 总是第1个被调用的函数。调用 `main`函数后，依次调用其他函数

* 函数是C程序的基本模块，一个完整的函数声明如下：

  ​    `函数类型  函数名 ( 参数1类型,  参数2类型，...) ；`

  * 注意声明时不必定义参数名，且圆括号与分号都不能少

*  完整函数定义：

       ```c
函数类型 函数名 (参数1类型 参数1名称, 参数2类型 参数2名称, ... )
      {
       函数体
      }
   
    ```
    
    ```
  
* { 表示函数开始；} 表示函数结束
  
* 注释方法：/**/与 //

  * /**/中间无论是几行都是注释
  * // 后面一行是注释

* 所有的C函数都使用==花括号==标记函数体的开始和结束，花括号还可用于把函数中的多条语句合并为一个单元或块（把多条语句合并为一条复杂语句）

* 声明是C语言最重要的特性之一，编译器通过变量的类型信息在内存中分配存储空间。这一片空间在用户方的名字就是变量名，在机器中则是对应的地址。声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。

* 在C语言中，所有变量都必须先声明才能使用。这意味着必须列出程序中用到的所有变量名及其类型。

* 可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称的第1个字符必须是字符或下划线，不能是数字。C语言的名称区分大小写。

* 在C语言中，调用函数时传递的信息是实际参数，定义函数时的变量是形式参数

* 调用函数时，只需输入函数名，并把所需的参数填入圆括号即可，当程序运行到此行时控制权被转给已命名的参数。函数执行结束后，控制权返回至主调函数，即调用时所属的函数

* 提高代码可读性的技巧：
  * 选择有意义的函数名
  * 写注释
  * 在函数中将概念上的多个部分隔离开来，该空行空行
  
* 函数定义时形参的声明必须一个一个的声明：参数1类型 参数1名称；参数2类型 参数2名称；...

* 在函数体内声明局部变量时可以一个一个声明，也可以同类型一次多个声明，注意加分号

* 通常来说，用户定义的函数在一个程序中会出现三次：
  * 函数原型，即函数声明，告知compiler函数的签名信息
  * 函数调用
  * 函数定义
  
* ==何时执行函数取决于函数在main函数中被调用的位置==，与其他无关
  
  * 从main函数开始看一个C语言的程序
  
* 程序的错误：bug；找出bug并修正：debug

* bug类型：
  * 语法bug。可借助compiler调整
  * 语义bug。与预期输出不符，需要仔细检查。
  
* 程序状态：给定时间点上所有变量值的集合

* 对于compiler而言，几乎正确仍然是错误

* 函数调用语句实质上是表达式语句，函数调用本身是一个表达式，圆括号是运算符，圆括号左边的函数名是运算对象



# 第三章 数据和C

两大数据类型：整数类型、浮点数类型

* scanf函数的几点说明
  * scanf(" ... ", ... , ... ,....)
  * scanf接受的数据类型是字符串和指针
  * 接受多少个指针类型与字符串中有多少个占位符有关
  * scanf只接受输入，无法输出
  * 如果格式符中没有间隔，可以在输入时用空格或回车作为输入的间隔
* float类型可以存储带小数的数字，在printf中使用 %f来打印float类型的变量，且可以使用%.nf控制精确输出小数点后n位的数据
  * 不要在浮点型常量中间加空格
* 常量 constant ：在程序运行期间没有变化
* 变量 variable ：在程序运行期间会改变或被赋值
* 定义变量需要声明数据类型，定义常量==直接#define 常量名称 常量值 即可，不需声明类型==
* 存储单元：
  * 位 bit，可以存储 0 或 1
  * 字节 byte， 1 byte = 8 bit。1个8位的字节有256种可能的0、1组合
  * 字(字长) word，与使用的电脑有关。64位的操作系统，1个word = 64 bit
* int：有符号整型。存储一个int要占用一个机器字长
  * 声明int变量：可以一次一个，也可以一次多个
  * 变量获取值有3种方法
    * 赋值
    * 通过函数(如 scanf) 获得值
    * 初始化变量
  * 初始化变量即在变量声明的同时赋值。最好是一次一个，否则容易引起误解
  * 如果以十进制显示数字，使用%d；以八进制显示数字，使用 %o；以十六进制显示数字，使用%x
* short int（或者简写为short）常用于较小数值的场合以节省空间。有符号
* long int （或者简写为 long）适用于较大数值的场合。有符号
* long long int （ long long）至少占64位。有符号
* unsigned int （unsigned）只用于非负值的场合

* 现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。

* 整数溢出时会重新从起始点开始。unsigned int 从0开始，int从负数开始

* 打印 unsigned int，使用%u；打印long，使用%ld( %lo, %lx)

* 打印short，使用 %hd( %do, %hx)

* char 类型用于储存字符，==是整数类型==，实际存储的是整数而不是字符。计算机使用数字编码来处理字符。在printf中使用 %c打印

* C语言把1 byte(8 bit)定义为 char 类型占用的位数

* 在C语言中，==单引号==括起的==单个字符==被称为字符常量，如果单引号内有多个字符会报错。**字符类型与字符串类型不同**

* 为字符类型的变量赋值可以使用字符常量，也可以用相应的ASCII码

  * 输出字符还是数值代码与 %c 和%d有关

  * int a 与 char a 区别仅在于占用的内存长度不同，char 是最小的整型
  * 如果确实是要输出字符类型，还是使用char，既明确又减少占用

* 代表行为的字符（如退格、换行等）表示方法：
  * 使用ASCII码
  * 使用转义序列
  
* printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式
  * printf("%c", grade); 输出grade的字符显示
  * printf("%d", grade);输出grade的整数表示
  
* 通常，系统储存一个浮点数float要占用32位。其中8位用于表示指数( e后面的部分 )的值和符号，剩下24位用于表示非指数( e前面的 )部分（也叫作尾数或有效数）及其符号。
  * e或E可以省略，如3.14159
  * 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。
  * 可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。
  * 不要在浮点型常量中间加空格
  
* double占用64位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。

* 通常情况下compiler会假定浮点型常量是double类型，使用双精度进行运算，然后截断成float类型的宽度。这样做的计算精度高，但是会减慢程序的运行速度

* 在浮点数后面加上 f 或 F 后缀可以覆盖默认设置，提高运行速度

* printf() 函数使用%f 打印==十进制的float 和 double 类型浮点数==，用 %e 打印指数计数法的十进制浮点数

* 如果系统支持十六进制格式的浮点数，可以用%a 输出指数计数法的十六进制浮点数

* C语言中有3种复数类型：
  * float_Complex
  * double_Complex
  * long double_Complex
  
* 3种虚数类型：
  * float_Imaginary
  * double_Imaginary
  * long double_Imaginary
  
* 如果包含 complex.h 头文件，可以使用 complex代替_Complex，用imaginary代替 _Imaginary，还可以用 I 代替 -1的平方根

* 类型大小：sizeof() 函数
  
  * 注意，要使用 %zd 匹配 sizeof() 的返回值
  
* 关键是要理解无论双引号中包含多少个字符和标点符号，==一个字符串就是一个参数。==
  * 区分 char 和 string！！！！！
  * ==char 是最小的整数类型==，只有1 byte
  
* C 语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。程序要知道函数的参数个数才能正常工作。printf()和scanf()函数用第1个参数表明后续有多少个参数，即==第1个字符串中的转换说明与后面的参数一一对应==。
  
* printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。

* C 标准明确规定了何时把缓冲区中的内容发送到屏幕：
  * 缓冲区满
  * 遇到换行字符
  * 需要输入的时候
  
* 从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区

* 还有一种刷新缓冲区的方法是使用fflush()函数



# 第四章 字符串和格式化输入 / 输出

* 字符串：使用数组存储的一组 char 变量，一个或多个字符的序列
* C语言中 双引号与单引号是必须区分的

```c
   // talkkback.c -- 演示与用户交互

   #include <stdio.h>
   #include <string.h>   // 提供 strlen() 函数的原型
   #define DENSITY 62.4  // 人体密度 (单位：磅 / 立方英尺)

   int main()
   {
       float weight,volume;
       int size,letters;
       char name[40];         // name 是一个可容纳 40 个字符的数组
       printf("Hi! What's your first name?\n");
       scanf("%s", name);
       printf("%s, What's your weight in pounds?\n", name);
       scanf("%f", &weight);
       size = sizeof name;
       letters = strlen(name);
       volume = weight / DENSITY;
       printf("Well, %s, your volume is %2.2f cubic feet.\n", name, volume);
       printf("Also, your first name has %d letters,\n", letters);
       printf("and we have %d bytes to store it.\n", size);
    // printf("%c", name[0]);
       return 0;
   }
```

* 上面的程序里，scanf() 中 name没有&前缀，而 weight 有。此处 &weight 和 name 都是地址
* #是一条C预处理指令
* strlen()可以获取字符串的长度
* C语言中用空字符 \0 标记字符串的结束。空字符不是数字 0，它是非空打印字符
* 由于C中的字符串一定以空字符结束，这意味着==数组的容量必须至少比待存储字符串中的字符数多1==。
* 什么是数组？
  * 数组是同类型数据元素的有序序列
* char name[40];
  * name 后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的元素数( 字符串中会少1 )。char 表明每个元素的类型
* scanf() 在遇到第 1 个空白时就不再读取输入。一般而言，scanf只会读取字符串中的一个单词，而不是一整句。
* 可使用fgets() 读取一般字符串
* 字符串常量"x"和字符常量'x'不同。
  *  区别之一在于'x'是基本类型（char） ， 而"x"是派生类型（char数组） ；
  *  区别之二是"x"实际上由两个字符组成： 'x'和空字符\0  
* sizeof() 函数以字节为单位给出对象的大小，返回类型为 %zd。这里的对象大小指整个变量占用的内存空间
* strlen() 给出字符串中的字符长度，遇到空字符'\0' 后就不再记录，因此strlen得到的结果小于等于sizeof。返回结果通常是unsigned或unsigned long。
* 处理长 printf() 语句的两种方法：
  * 将 printf() 语句在参数之间( 逗号之后 ) 分为两行。
  * 使用两个 printf()，只在第2个printf中使用换行符
* 定义符号常量的方法：
  * 预处理，#define name value
  * 使用 const type name value



```c
/* praise1.c -- 使用不用类型的字符串 */
#include <stdio.h>
#define PRAISE "You are an extraordinary being."
int main(void)
{
    char name[40];
    printf("What's your name?");
    scanf("%s", name);
    printf("Hello, %s, %s\n", name, PRAISE);
    return 0;
}
```

* scanf() 只读取了 Meng Zixuan 中的 Meng，它在遇到第一个空白 (空格、制表符或换行符)  时就不再读取输入。

* 一般而言，根据 %s 转换说明，scanf() 只会读取字符串中的一个单词，而不是一整句。C 语言还有其他的输入函数 ( 如，fgets() )，用于读取一般字符串。

* 字符串常量 " x " 和 字符常量 ' x ' 不同。

  * 区别之一在于：' x ' 时是基本类型 char，而 " x " 是派生类型 char数组
  * 区别之二在于：" x " 实际上由两个字符组成：' x ' 和空字符 \0

* sizeof 运算符：以字节为单位给出对象的大小

* strlen() 函数给出字符串中的字符长度

* 1字节存储一个字符，但两种方法应用于字符串得到的结果并不相同

* strlen() 只记录字符串中空字符 \0 以前的长度，sizeof 则计算字符串中的全部字符，因此 sizeof 给出的数不小于 strlen 

* C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了 %zd 转换说明，这对于 strlen() 同样适用

* sizeof 是否使用圆括号取决于运算对象是类型还是变量

  * 对于类型，必须写成 sizeof(char)，sizeof(float)
  * 对于变量，可以写成 sizeof name 或者 sizeof 6.28

* 为方便起见，建议所有情况下都使用圆括号 sizeof(6.28)

* 预处理定义的常量也成为明示常量( manifest constant )

  * 通用格式：#define NAME value

* C90 标准新增了 const 关键字，用于限定一个变量为只读：

  ```c
      const int MONTHs = 12; // MONTHS 在程序中不可更改，值为12
  ```

* 这使得 MONTHS 成为一个只读值，const使用起来比 #define 更灵活

* 在转义字符 %f 或%d 中可以指定输出的数据宽度

  * %4.2f 输出字符宽度为4的浮点数，其中小数点后有两位数字。
  * %10.3E 输出字符宽度为10的指数浮点数，其中尾数部分的小数点右侧有3位有效数字
  * [%24.5s] 输出字符宽度为24的字符串，.5限制了待打印的字符个数为5个字符
  * %.3 自动分配恰好打印的字符宽度，小数点有效数字为3或打印3个字符

* 转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。

* printf()函数也有一个返回值，它返回打印字符的个数。

* printf函数的语句太长在屏幕上不方便阅读时，可以把一条语句写成多行。

* 如果用 scanf() 读取基本变量类型的值，在变量名前加上一个 &；

* 如果用 scanf() 把字符串读入字符数组中，不需要使用&

  * 只是在scanf中对数组不用加&

* scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符(如逗号,)必须与输入字符串严格匹配。

* 在C语言中scanf()并不是最常用的输入函数，但它可以读取不同类型的数据

* scanf()函数返回成功读取的项数。

* printf()和scanf()都可以使用*修饰符来修改转换说明的含义。

* printf() 中的*用于代替字段宽度和精度，需要在参数中告诉函数它的值。( 相当于占位符中的占位符 )

* scanf中的 * 用于跳过相应的输出项。

* 想把数据打印成列，指定固定字段宽度很有用。  

* 另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适， 没有不必要的空白。   



# 第五章 运算符、表达式和语句

## 循环

* 循环(loop)，while循环，for循环。计算机最擅长重复计算

## 基本运算符

* 赋值运算符：= 赋值行为从右往左进行，左侧必须引用一个存储位置。

  * 用于储存值的数据存储区域统称为数据对象(data object)。在C语言中的术语为可修改的左值(modifiable lvalue)或对象定位值(object locator value)

  * C 语言支持连续赋值(Python也是)：

    ```c
    a = b = c =5
    //a,b,c的值都是5
    ```

* 加法运算符：+

* 减法运算符：-   

  *  \+ 和 - 运算符都被称为二元运算符(binary operator)，需要两个运算对象才能完成操作
  * 减号还可用于标明或改变一个值的代数符号，此时的 - 被称为一元运算符

* 乘法运算符：*

* 除法运算符：/

  * 整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数进行除法的结果是整数，其商的小数部分被丢弃。这一过程被称为截断(trucation)
  * 尽量避免使用混合类型。混合整数和浮点数计算的结果是浮点数。
  * C99标准规定采用“趋零截断”的舍入方法，既直接丢弃小数部分

* 运算符优先级

  * 先执行高优先级的运算符，再执行低优先级的运算符
  * 相同优先级的运算符一般按从左到右的顺序进行(=运算符除外)
  * 可以使用圆括号来更改执行的顺序

* 当运算符共享一个运算对象时，优先级决定了求值顺序。结合律只适用于共享同一运算对象运算符

## 其他运算符

* sizeof 运算符和size_t类型

  * sizeof运算符以字节为单位返回运算对象的大小。如果运算对象是类型，则必须用圆括号将其括起来
  * C 语言规定，sizeof返回size_t类型的值。size_t是一个无符号整数类型，但并非新类型。size_t是语言定义的标准类型。C 有一个typedef机制，允许程序员为现有类型创建别名。
  * typedef double real;
  * 这样，real就是double的别名。可以声明一个real类型的变量；
  * real deal; // 编译器查看real时会发现，在typedef声明中，real已经成为double的别名，于是把deal创建为double类型的变量。
  * 类似的，在C的头文件系统中可以使用typedef把size_t作为unsigned int或unsigned long的别名。 
  * C99新增了 %zd 转换说明用于printf()显示 size_t类型的值
* 求模运算符： %
  * 只能用于**整数**运算，给出其左侧整数除以右侧整数的余数
  * 常用于控制程序流
  * 负数求模如何运行？
    * 如果第一个对算对象(被除数)是负数，那么求模的结果为负数；如果第一个对算对象是正数，那么求模的结果也是正数
    * 无论何种情况，只要 $a$ 和 $b$ 都是整数值，就可以通过$a-\frac{a}{b}\times b$ 来计算 $a \% b$ 
* 递增运算符：++
  * 有前缀模式和后缀模式，区别在于递增行为发生的时间不同。前缀模式先递增后使用，后缀模式先使用后递增。
    * 单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。
  * 把变量的递增过程放入 while循环的条件中，这种结构在 C 语言中很普遍
  * 好处：使得程序更加简洁，把控制循环的两个过程集中在一个地方，不会忘记更新循环
* 递减运算符：--
* 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。
* 递增和递减运算符只能影响一个变量（一个可修改的左值）
  * (x*y)++    这种写法是无效的
* 在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。
  * 遵循的原则：
    * 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；
    * 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。

## 表达式和语句

* C 表达式由运算符和运算对象组成。它的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作
* 有赋值运算符的表达式的值与赋值运算符的左侧变量的值相同
  * q = 5 * 2作为一个整体的值是10。
  * 3 > 2 的值为 1。
  * 6 + (c = 3 + 8) 的值为 17。
* 在C语言中任何表达式加上分号 ； 都可以看作是一条语句。如果不加分号 ；只能是一个表达式。
* 真正有用的语句是指改变值或者调用函数的表达式
* C语言术语：**副作用(side effect)**
  * 副作用是对数据对象或文件的修改
  * states = 50; 的副作用是将变量的值设置为50
* 从C语言的角度看，主要目的是对表达式求值，而程序员的主要目的可能是使用其副作用
* 类似地，调用 printf()函数时，它显示的信息其实是副作用。printf()的返回值是待显示字符的个数）

* 序列点(sequence point)是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在C语言中，**语句中的分号标记了一个序列点**

  * 在一个语句中，运算符对运算对象做的改变(副作用)**必须在程序执行下一条语句之前完成**

  * **任何一个完整表达式的结束也是一个序列点**

  * 序列点有助于分析后缀递增何时发生

    ```c
    while (guests++ < 10)
        printf("%d \n", guests);
    ```

  * 表达式guests++ < 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）。同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。

* 复合语句(compound statement)是指用花括号括起来的一条或多条语句

  * 在C语言中，缩进对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。

## 类型转换

* 类型升级通常不会有什么问题，但是类型降级会导致真正的麻烦
* 强制类型转换运算符(cast operator)：圆括号和它括起来的类型名
  * （type） 将其右侧的值转换成圆括号中指定的类型



## 带参数的函数

* 如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。
* 如果函数接受一个 int 类型的参数，则圆括号中包含一个int类型变量的
  声明。**其他非int类型的变量传入时会被强制转换程int类型的变量**
* 在英文中，argument和parameter经常可以互换使用，但是C99标准规定实参(函数调用时的参数)使用术语argument；形参(函数声明时的参数)使用术语parameter



## 关键概念

* C 通过运算符提供多种操作，运算符和运算对象组成了表达式。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。
* **每个C表达式都有一个值。**即使是赋值表达式
* 不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。



# 第六章 C控制语句：循环

**3种程序流**：

         1. 顺序执行
            2. 循环执行
            3. 分支执行

## while(不确定循环)

* while语句创建了一个循环，重复执行直到测试表达式为假或0。

* while语句是一种**入口条件循环**，也就是说，在执行多次循环之前已决定是否执行循环。因此，循环有可能不被执行。

* 循环体可以是简单语句，也可以是复合语句。

* scanf("", &) 函数如果成功读入符合声明类型的数据，会返回读入数据个个数

* 如果没有读入符合声明类型的数据，那么scanf的返回值就是0

* 利用scanf的上述特性可以直接将其作为while循环的循环判断条件

* 通用形式：

  * while (expression){

    ​    statement

    }

* 终止while循环：
  * 让expression的值有变化，最终为假
  * expression值不变，是死循环，用break和if语句来终止
* 使用while时，要牢记一点：只有在测试条件后面的单独语句即statement部分才是循环内容
  
  * 如果不加 { } 则statement只是紧跟while的下面一行语句
* 关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关系表达式。
* 关系表达式可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，**不能用关系运算符比较字符串**
* 比较浮点数相等时尽量用**两者的差小于某个很小的数**来代替，因为计算机中的浮点数都是不准确的

* 只要 expression 的值是非0的，就认为是True
* 多用while(goats) 而不是 while(goats != 0)

### _Bool 类型变量

* \_Bool类型的变量只能储存1（真）或0（假）。如果把其他非零数值赋给\_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。

### 真值的问题

* 如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。
* 不要在本应使用 == 的地方使用 = 

## for(计数循环)

* 在创建一个重复执行固定次数的循环中涉及了3个行为：
  1.必须初始化计数器；
  2.计数器与有限的值作比较；
  3.每次循环时递增计数器。

* for循环把上述3个行为（初始化、测试和更新）组合在一处。

* 通用形式：

  * for( expression1 ; expression2 ; expression3 ){

    ​    statement

    }

  * 关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。

    * 第1个表达式是初始化，只会在for循环开始时执行一次。
    * 第2个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假，则循环结束。
    * 第3个表达式执行更新，在每次循环结束时求值。

  * for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。

* 可以省略一个或多个控制表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。

* for语句是一种**入口条件循环**，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。

## 逗号运算符

**逗号也可用作一种运算符**

* 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。

* 逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。
* 逗号是一个序列点，逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生，它保证了被它分隔的表达式从左往右求值
* 整个逗号表达式的值是右侧项的值

逗号也可用作分隔符

## do while(出口条件循环)

* 通用形式：

  * do 

  ​      statement

  ​    while ( );

* do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次。适用于那些至少要迭代一次的循环

## 如何选择循环

* 如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条
  件循环。通常，入口条件循环用得比较多，有几个原因。

  * 其一，一般原则是在执行循环之前测试条件比较好。
  * 其二，测试放在循环的开头，程序的可读性更高。
  * 另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。

* 那么，假设需要一个入口条件循环，用for循环还是while循环？

  * 这取决于个人喜好，因为二者皆可。

  * 要让for循环看起来像while循环，可以省略第1个和第3个表达式。

    * for(;test;)
    * while(test)   // 两者效果相同

  * 要让while循环看起来像for循环，可以在while循环的前面初始化变量，并在while循环体中包含更新语句。

    * 初始化；

    ​    while( test )

    ​    {

    ​        statement

    ​        update

    ​    }

    * for(初始化; test; update)

      {

      

      }  //两者效果相同

## 嵌套循环(nested loop)

* 嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。
* 嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。



## 数组简介

* 数组可以作为一种储存多个相关数据的便利方式。循环经常用到数组

* 数组（array）是**按顺序储存**的**一系列类型相同的值**，如10个char类型的字符或15个int类型的值。

* 整个数组有一个数组名，通过整数下标访问数组中单独的项或元素（element）。
  * 注意，数组元素的编号从0开始，不是从1开始。可以给每个元素赋相同类型的值。
  * 实际上，使用数组元素和使用同类型的变量一样。
  * 这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。
  * 数组的类型可以是任意数据类型。
  
* 数组长度可以是宏定义的常量，但==不能是一个变量==

  ```c
  ...
  #define SIZE 10
  ...
  int arr[SIZE];//有效
  /* ********************************** */
  int n = 10;
  int arr[n];// 无效
  ```

  

* 字符串：
  
  * 可以把字符串储存在 char 类型的数组中。如果 char 类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串

![image-20201127120447550](note%20for%20C.assets/image-20201127120447550.png)

* 用于识别数组元素的数字被称为下标（subscript）、索引（indice）或偏移量（offset）。
* 下标必须是整数，而且要从0开始计数。
* 数组的元素被依次储存在内存中相邻的位置
* 声明格式：
  * type name[size]
  * 最终name**能取到的下标是 size - 1**，其长度为size，从0开始取



### 在 for 循环中使用数组

```c
#include <stdio.h>
#define SIZE 10
#define PAR 72

int main(void){
	int index, score[SIZE];
	int sum = 0;
	float average;
	printf("Enter %d golf scores:\n", SIZE);
	for(index = 0; index < SIZE; index++)
	    scanf("%d", &score[index]);
	printf("The scores read in are as follows:\n");
	for(index = 0; index < SIZE; index++)
	    printf("%5d", score[index]);    //验证输入
	printf("\n");
	for(index = 0; index < SIZE; index++)
	    sum += score[index];
	average = (float)sum / SIZE;
	printf("Sum of scores = %d, average = %.2f\n", sum, average);
	printf("That's a handicap of %.0f.\n", average - PAR);	
	return 0;
}
```

* 由于`scanf()`会跳过空白字符，所以可以在一行输入10个数字，也可以每行只输入一个数字，或者像本例这样混合使用空格和换行符隔开每个数字
* 该程序示例演示了一些较好的编程风格。
  * 第一，用`#define`指令创建的明示常量（SIZE）来指定数组的大小。
  * 第二，下面的代码可以很方便地处理一个大小为`SIZE`的数组：
    * ` for (index = 0; index < SIZE; index++)`
  * 第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确保程序处理的数据与期望相符。

## 使用函数返回值的循环

* 编写一个有返回值的函数，要完成以下内容：
   1.定义函数时，确定函数的返回类型；
   2.使用关键字return表明待返回的值。
* 要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 return 表明该函数将把它后面的值返回给主调函数。
  * 返回值也可以是表达式的值

* 如果把函数的定义置于main()的文件顶部，就可以省略前置声明
* 但是，这不是C的标准风格。因为main()通常只提供整个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。



# 第七章 C控制语句：分支和跳转

## if 语句

* if 语句的通用形式：

​				if ( expression )

​				statement

* 如果对 expression 求值为真 ( 非 0 )，则执行 statement；否则，跳过 statement。与while循环一样，statement可以是一条简单语句或复合语句。
* 如果statement是一条简单语句，则直接在if 的下一行写完加上分号即可；如果是复杂语句，需要用花括号括起形成一段语句块==即使if语句由复合语句构成，整个if语句仍被视为一条语句。==
* if 语句的结构和 while 语句很相似，它们的主要区别是：如果满足条件可执行的话，if 语句只能测试和执行一次，而 while 语句可以测试和执行多次

## if else 语句

* if 和 else 之间只允许一条语句( 简单语句或复合语句 )，因此如果要在 if 和 else 之间执行多条语句，必须用花括号把这些语句括起来成为一个块



## getchar() 和 putchar()

* 字符输入输出函数：
  * getchar()
  * putchar()

* getchar()函数不带任何参数，它从输入队列中返回下一个字符。

* putchar()函数打印它的参数。

* 由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。
* 注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件中

* 示例程序:如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符。

```c
// cypher1.c -- 更改输入，空格不变
#include <stdio.h>
#define SPACE ' '　　　　　　　 // SPACE表示单引号-空格-单引号
int main(void){
    char ch;
    ch = getchar();　　　　　　 // 读取一个字符
    while (ch != '\n'){　　　　 // 当一行未结束时
        if (ch == SPACE)　　　 // 留下空格
            putchar(ch);　　　 // 该字符不变
        else
            putchar(ch + 1);　 // 改变其他字符
            ch = getchar();　　　　// 获取下一个字符
    }
    putchar(ch);　　　　　　　　// 打印换行符
    return 0;
}    
```

* 使用输入项的值来判断是否结束循环。

* ctype.h 提供了一个 isalpha()函数来判断实参是否为一个字母。
* 还提供了tolower(), toupper()来返回实参的小写, 大写（不改变原始参数）

![image-20201127125811096](note%20for%20C.assets/image-20201127125811096.png)

```c
// cypher2.c -- 替换输入的字母，非字母字符保持不变
#include <stdio.h>
#include <ctype.h>

int main(void){
    char ch;
    while((ch = getchar()) != '\n'){
        if(isalpha(ch))   //如果是一个字符
            putchar(ch + 1); //显示该字符的下一个字符
        else
            putchar(ch); // 原样显示
    }
    putchar(ch);    // 显示换行符
    return 0;
}
```



## 多重选择 else if

* else if 是已学过的 if else 语句的变式。
* else 与 if 配对
  * 规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来

![image-20201127130410999](note%20for%20C.assets/image-20201127130410999.png)



## 逻辑运算符

* 如果导入了<stdbool.h>，则可以用bool 类型替换\_Bool类型
* 有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。
* 这种情况下可以使用逻辑运算符(或||且&&非！)，并使用句点（.）标识句子的末尾。

* 导入<ios646.h>后可以用 and代替&&，or代替||，not代替！

## 一个统计单词的程序

* 该程序读取并报告单词的数量，还可以计算字符数和行数

  * 要逐个字符读取输入，知道何时停止读取
  * 能识别并计算这些内容：字符、行数和单词

  pseudo_code: 

  ```pseudocode
  读取一个字符
  当有更多输入时：
      递增字符计数
  如果读完一行
      递增行数计数
  度过读完一个单词
      递增单词计数
  读取下一个字符
  输入的循环模型：
  while((ch = getchar()) != stop)
  {
  ...
  }
  ```

  

* stop表示能表示输入末尾的某个值，选用|

## 条件运算符：？

* C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式该表达式使用?:条件运算符。
* 该运算符分为两部分，需要3个运算对象，称为三元运算符。
* 条件运算符是C语言中唯一的三元运算符

​       `x=(y < 0)? -y:y;`

* 在 = 和 ; 之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x = -y;否则，x = y”。
* 用if else可以这样表达：

```c
if(y < 0)
    x = -y;
else
    x = y;
```

* 条件表达式的通用形式如下：
  * expression1 ? expression2 : expression3
* 如果 expression1 为真（非0），那么整个条件表达式的值与expression2的值相同
* 如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。

* 通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。

## 循环辅助：continue 和 break

### continue 语句

* 3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。
  * 对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值。
  * 对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
* 如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。

### break语句

* 程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。

* 如果break语句位于嵌套循环内，它只会影响包含它的当前循环。

![image-20201127161236364](note%20for%20C.assets/image-20201127161236364.png)

* break还可用于因其他原因退出循环的情况。

* 在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。
* 嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break：



## 多重选择：switch 和 break

* 使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if...else来完成。但是，大多数情况下使用switch语句更方便。

* switch (expression){ // 表达式的值必须是一个整数值，包括char

  ​    case 1:

  ​        statement_1

  ​        break;

  ​    ...

  ​    case n:

  ​        statement_n 

  ​        break;

  ​    default:        //可选

  ​        statement_n+1

  }

* 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。
* expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。

![image-20201127164937558](note%20for%20C.assets/image-20201127164937558.png)

## goto语句(程序跳转)

* break和continue是goto的特殊形式。
* C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）



## 关键概念

* 要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符(或且非)把两个完整的测试表达式组合起来。



# 第八章 字符输入/输出和输入验证

## 单字符I/O：getchar()和putchar()

* getchar()和 putchar()每次只处理一个字符，要处理多个字符时可以使用while循环语句
* 是绝大多数文本（即，普通文字）处理程序所用的核心方法。
* getchar()和 putchar()都不是真正的函数，它们被定义为供预处理器使用的宏

## 缓冲区

* 大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。
* 用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。

![image-20201127200957328](note%20for%20C.assets/image-20201127200957328.png)

## 结束键盘输入

* 从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。

* >流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。
  >
  >![img](note%20for%20C.assets/2012121818014532.png)
  >
  >流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。
  >
  >可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。
  >
  >![img](http://pic002.cnblogs.com/images/2012/79891/2012121719220226.jpg)
  >
  >当程序需要从某个数据源读入数据的时候，就会开启一个输入流，数据源可以是文件、内存或网络等等。相反地，需要写出数据到某个数据源目的地的时候，也会开启一个输出流，这个数据源目的地也可以是文件、内存或网络等等。

  ​                                                              [来自CSDN](https://blog.csdn.net/hansnowqiang/article/details/50130437)

* 计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。

* 操作系统使用的另一种方法是储存文件大小的信息。

* 如果文件有3000字节，程序在读到3000字节时便达到文件的末尾

* 无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：
  
  * #define EOF (-1)


* 为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。
* 无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。
* 这里关键要理解**EOF是一个值**，标志着检测到文件结尾，并不是在文件中找得到的符号。

```c
/* echo_eof.c -- 重复输入，直到文件结尾 */
#include <stdio.h>
int main(void){
    int ch;
    while ((ch = getchar()) != EOF)
        putchar(ch);
    return 0;
}//Ctrl+Z可以结束输入或整个程序
```

* 每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打印该输入行的副本

## 重定向和文件

* 输入和输出涉及函数、数据和设备。

  * 在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。

  * 然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。

    ```shell
    ./echo_eof < words
    words 是具有内容的文件，用此命令用echo_eof程序输出words的内容，即重定向输入
    ```

* 程序可以通过两种方式使用文件。

  * 第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。
  * 第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。

*  < 符号是UNIX和DOS/Windows的重定向输入运算符

*  < 符号是重定向输出运算符

      ```shell
  ./echo_eof > mywords
  把echo_eof的输出重定向至该文件，注意使用 Ctrl + D 在UNIX系统中结束
  ```

  ![image-20201207144533965](note%20for%20C.assets/image-20201207144533965.png)

![image-20201207144544921](note%20for%20C.assets/image-20201207144544921.png)

![image-20201207144604562](note%20for%20C.assets/image-20201207144604562.png)

* 组合重定向：
  * 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：
             echo_eof < mywords > savewords
* 总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（<和>）时，要遵循以下原则。
  * 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。
  * 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。

* 重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。

  

## 创建更友好的用户界面

* 使用缓冲输入，要求用户按下enter键发送输入
* 在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计程序处理用户的错误输入。在用户出错时通知用户再次输入。
* getchar()读取每个字符，包括空格、制表符和换行符；
* 而 scanf()在读取数字时则会跳过空格、制表符和换行符。

## 菜单浏览

* 现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。



## 关键概念

* C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个
  字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以
  把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘
  输入，用文件代替显示器输出。
* 程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可
  能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好。
* 对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问
  题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可
  以给用户提供有限次或无限次机会重新输入。
* 混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输
  入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程
  序中妥善处理。
* 编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错
  误，然后设计程序妥善处理这些错误情况。











# 第九章 函数

## 函数复习

* 函数功能：
  * 1、执行某些动作，如printf() 把数据打印到屏幕上
  * 2、找出一个值供程序使用，如strlen() 把指定字符串的长度返回给程序、
  * 3、改变内存的值，==使用指针==进行通信
* 如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及 printf()生成的输出，无需了解 printf()的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上
* 描述性的函数名能清楚地表达函数的用途和组织结构。然后单独设计和测试每个函数，直到函数都能正常完成任务。在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系
* 了解函数：正确地定义函数、调用函数、建立函数间的通信
* 通常用户要使用自己定义的函数user_function需要在3处使用user_function标识符：首先声明函数原型，一般在main函数之前，告诉compiler user_function返回值的类型和函数接受的参数类型，==这些信息称为该函数的签名( signature)==；然后是函数调用，一般在main 函数之内，表明在此处执行函数；最后是函数定义，明确定义函数要做什么
* 注意：声明函数原型要带分号，定义函数不带分号且要用花括号
* ==任何函数和变量在使用之前都要声明该函数或的类型==

### 创建简单函数

* 下面以具体的程序为例进行说明

  ```c
  /* lethead1.c*/
  
  #include <stdio.h>
  #define NAME "GIGTHINK, INC."
  #define ADDRESS "101 Megabuck Plaza"
  #define PLACE "Megapolis, CA 94904"
  #define WIDTH 40
  
  void starbar(void); /*函数原型。注意必须先在主函数之前声明要用到的函数名，然后在主函数之后具体定义此函数*/
  
  int main(void){
      starbar();
      putchar('\n');
      printf("%s\n", NAME);
      printf("%s\n", ADDRESS);
      printf("%s\n", PLACE);
      starbar();     /*使用函数*/
      return 0;
  }
  
  void starbar(void){   /*定义函数*/
      int count;
      for (count = 1; count <= WIDTH; count++)
      {
          putchar('*');
      }
      
  }  
  ```

* void starbar(void);

  * 圆括号表明starbar是一个函数名
  * 第一个void是函数类型，void类型表明没有返回值
  * 第二个void表明该函数不带参数
  * ==分号表明这是在声明函数，不是在定义函数==，告诉compiler在别处查找该函数的定义
  * 有一些老版本的编译器甚至识别不了 void，如果必须使用这种编译器，可以把没有返回值的函数声明为 int 类型
  * 对于starbar函数而言，该函数没有返回值，没有参数
  * 声明函数原型一般在main函数之前，也可以在main函数之后

* starbar();

  * 这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling  function）继续执行下一行
  * starbar()函数中的变量count是局部变量（local  variable），意思是该变量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用count，这不会引起名称冲突，它们是同名的不同变量。

###  函数参数

* starbar() 函数只能打印星号，且只能打印40个，并不美观。这是因为starbar()函数没有用函数参数，因此编写show_n_char(chartype, number) 函数来控制要打印的字符类型与个数

  ```c
  /* lethead2.c*/
  
  #include <stdio.h>
  #include <string.h>    /* 为 strlen() 提供原型*/
  #define NAME "GIGATHINK, INC."
  #define ADDRESS "101 Megabuck Plaza"
  #define PLACE "Megapolis, CA 94904"
  #define WIDTH 40
  #define SPACE ' '
  
  void show_n_char(char ch, int num);
  int main(void){
      int spaces;
      show_n_char('*', WIDTH);   /*用符号常量作为参数*/
      putchar('\n');
      show_n_char(SPACE,12);       /*用符号常量作为参数*/
      printf("%s\n", NAME);
      spaces = (WIDTH - strlen(ADDRESS)) / 2;    /*计算要跳过多少个空格*/
      show_n_char(SPACE, spaces);  /*用一个变量作为参数*/
      printf("%s\n", ADDRESS);
      show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
      printf("%s\n", PLACE);       /*用一个表达式作为参数*/ 
      show_n_char('*', WIDTH);
      putchar('\n');
      return 0;
  }
  
  /*show_n_char() 函数的定义*/
  void show_n_char(char ch, int num){
      int count;
      for (count = 1; count <= num; count ++)
      putchar(ch);
  }
  ```

* void show_n_char(char ch, int num)；

  * 该行告知compiler函数使用两个参数 ch 和 num，ch 是 char 类型，num 是 int 类型。在圆括号内定义的这两个变量称为形式参数( formal argument, 形参)。与定义在函数中的变量一样，形参也是局部变量，每次调用函数，必须给这些变量赋值，实际参数( actual argument, 实参) 提供了赋给形参的值。
  * 该行末尾的分号表明此处是声明函数。在声明函数时圆括号内可以只写形参的类型，无需写具体的形参名==在函数定义时则必须写明==
  * 形参的定义必须在每个变量前都声明，即使他们是同一个类型。这一点与普通变量声明时不同
  * 实际参数是出现在函数调用时圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。实际参数可以是常量、变量，或甚至是更复杂的表达式。==无论实际参数是何种形式都要求值==
  * 局部变量的好处是将不同的函数隔离开，彼此相当于黑盒，互不影响

* 在主函数中通过实参 -> 形参把主函数中的值传递到子函数中，而子函数可以使用return将子函数中的值传回主函数

  ```c
  /* lesser.c -- 找出两个整数中较小的一个*/
  #include <stdio.h>
  int imin(int, int);
  
  int main(void){
      int evil1, evil2;
      printf("Enter a pair of integers (q to quit):\n");
      while (scanf("%d %d", &evil1, &evil2) == 2){
          printf("The lesser of %d and %d is %d.\n", evil1, evil2, imin(evil1, evil2));
          printf("Enter a pair of integers (q to quit):\n");
      }
      printf("Bye.\n");
      return 0;
  }
  int imin(int n, int m){
      int min;
      if (n < m)
      min = n;
      else
      min = m;
      return min;
  }
  ```

* 驱动程序（driver）：被设计用于测试函数的程序

### 使用return从函数中返回值

* 关键字return后面的表达式的值就是函数的返回值。

  * 返回值不仅可以赋给变量，也可以被用作表达式的一部分。

  * 返回值不一定是变量的值，也可以是任意表达式的值。

    ```c
    /* 返回最小值的函数，第2个版本 */
    imin(int n,int m)
    {
    return　(n　<　m)　?　n　:　m;
    }
    ```

  * 虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。

* 使用 return 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。

  * 执行return语句后，下面的语句不再被执行

* 还可以直接使用 `return;`语句终止函数，没有返回值。

  * 只能使用在 void 类型的函数中

* 许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。

* 但是，在函数中使用多个return语句也没有错。

### 函数类型

* 声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。
* 类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。
* ==要正确地使用函数，程序在第一次使用函数之前必须知道函数的签名.==通常的做法是提前声明函数，把函数的签名提前告知compiler

* 当float类型被作为参数传递时会被升级为double类型




## ANSI C函数原型

* 主调函数把它的参数储存在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。

* 调用函数时主调函数会==先根据实参==向栈中存入相应位数的值，然后被调函数==再由形参==向栈中读取相应位数的值。
* 如果==实参与形参的类型不一致==，那么调用函数时读取到的参数(形参的位数)就会与实参不同，进而出错。
* 针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型
* 函数声明时( 带分号 )定义的变量名是假名，与函数定义时( 带花括号 )定义的不必相同，因此函数声明时可以只给出变量的类型与个数，等函数定义时再具体定义变量名，并且此变量为局部变量
* printf() 函数中的第一个参数是一个字符串，而==其他的参数类型与数量都要根据字符串参数来确定==

  * printf("%d  %d  %.2f  %s", a, b, c, d)
  * 根据第一个参数"%d  %d  %.2f  %s"可知后面还有4个类型分别为整型、整型、浮点型、字符串型的参数
  * C语言里函数的参数( 圆括号内的变量 )都是用逗号隔开的
* 如果函数比较简单，可以将函数声明略去，直接再main函数之前定义函数。
* 总之必须牢记：==要正确地使用函数，程序在第一次使用函数之前必须知道函数的签名.==



## 递归 recursion

* C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点

* 可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。

* 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。
* 一般而言选择循环比较好。递归使用的内存多、执行速度慢。递归不方便阅读和维护
* 递归在处理倒序时非常方便

* 递归的几个要点

  * 每级函数调用都有自己的变量。虽然它们的变量名可能相同，但地址不同（相当于每次递归调用都会创建各自的独立的局部变量）
  * 每次函数调用完毕都会返回一次上一级递归。递归调用是层层嵌套的，程序必须按顺序逐级返回递归
  * 递归函数中位于递归调用之前的语句，均按被调函数的顺序执行
  * 递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用
  * 虽然每级递归都有自己的变量，但是并没有复制代码，每次递归相当于又从头开始执行原来写好的代码。除了为每次递归调用创建新的局部变量之外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替
  * 递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用 if 或其他等价的测试条件在函数形参等于某特定值时终止递归。==为此，每次递归调用的形参都要使用不同的值==

* 递归和倒序计算

  * 当处理倒序问题时，递归比循环简单
  * 问题：编写一个函数，打印一个整数的二进制数
  * 一般而言，对于数字 n，其二进制的最后一位是 n % 2，计算的第一位数字实际上是带输出二进制数的最后一位==在递归函数的递归调用之前计算 n % 2，在递归调用之后打印计算结果==。这样，计算的第1个值正好是最后一个打印的值。
  * 要获得下一位数字，就必须把原数整除2，再将商对2取取余数。举例来说，5 % 2 = 1，第一位是1；5 / 2 = 2，2 % 2 = 0，第二位是0；2 / 2 = 1，1 % 2 = 1，第三位是1；==停止条件：与2相除（整除以2）的结果小于2时停止==，因此 5 的二进制数就是 101
  * putchar() 中只能输入 ' '，不能用 " "
  * 在C语言中，可以通过\n来控制不同的printf函数输出是否在同一行，不带\n 则将会与下一个printf在同一行。==同一行的输出可以由多个printf组成==

* 递归创建斐波那契数列

  ```c
  unsigned　long　Fibonacci(unsigned　n)
  {
  if　(n　>　2)
  return　Fibonacci(n-1)　+　Fibonacci(n-2);
  else
  return　1;
  }
  ```

  * 该函数使用了双递归（double recursion），即函数每一级递归都要调用本身两次。
  * 由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！
  * 在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。
  * ==在程序中使用递归要特别注意，尤其是效率优先的程序。==



## 编译多源代码文件的程序

* 使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。
  
* 所有的C函数皆平等

  * 程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。

* 把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。

  * 例子：

    ​		假设要管理4家酒店的客房服务，每家酒店的房价单价不同，但是每家酒店所有房间的总房价相同。对于预订住宿多天的客户，第2天的房费时第1天的95%，第3天时第2天的95%，以此类推。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。

  ```c
  /* usehotel.c -- 房间费率程序*/
  /* 与hotel.c一起编译 */
  #include <stdio.h>
  #include "hotel.h" // 定义符号常量，声明函数
  
  int main(void){
      int nights;
      double hotel_rate;
      int code;
      while ((code = menu()) != QUIT){
          switch(code){
              case 1: hotel_rate = HOTEL1;
                  break;
              case 2: hotel_rate = HOTEL2;
                  break;
              case 3: hotel_rate = HOTEL3;
                  break;
              case 4: hotel_rate = HPTEL4;
                  break;
              default: hotel_rate = 0.0；
              printf("Oops!\n");
                  break;
          }
          nights = getnights();
          showprince(hotel_rate, nights)
      }
      printf("Thank you and goodbye.\n");
      return 0;
  }
  ```

* hotel.c 函数支持模块

  ```c
  /* hotel.c -- 酒店管理函数 */
  #include <stdio.h>
  #include "hotel.h" 
  
  int menu(void){
      int code, status;
      printf("\n%s%s\n", STARS, STARS);
      printf("Enter the number of the desired hotel:\n");
      printf("1) Fairfield Arms            2) Hotel Olympic\n");
      printf("3) Chertworthy Plaza         4) The Stockton\n");
      printf("5) quit\n");
      printf("%s%s\n", STARS, STARS);
      while ((status = scanf("%d", &code)) != 1 || (code <1 || code > 5)){
          if (status != 1)
              scanf("%*s"); //处理非整数输入
          printf("Enter an interger from 1 to 5, please.\n");
      }
      return code;
  }
  
  int getnights(void){
      int nights;
      printf("How many nights are needed? ");
      while (scanf("%d", &nights) != 1){
          scanf("%*s");       // 处理非整数输入
          printf("Please enter an integer, such as 2.\n");
      }
      return nights;
  }
  
  void showprice(double rate, int nights){
      int n;
      double total = 0.0;
      double factor = 1.0;
      for (n = 1; n <= nights; n++, factor *= DISCOUNT)
          total += rate * factor;
      printf("The total cost will be $%0.2f.\n", total);
  }
  ```

* 

  ```c
  /* hotel.h -- 符号常量和 hotel.c 中所有函数的原型*/
  #define QUIT 5
  #define HOTEL1 180.00
  #define HOTEl2 225.00
  #define HOTEL3 255.00
  #define HOTEL4 355.00
  #define DISCOUNT 0.95
  #define STARS "*******************************"
  //显示选择列表
  int menu(void);
  //返回预订天数
  int getnights(void);
  //根据费率、入住天数计算费用并显示结果
  int showprice(double rate, int nights);
  ```



## 查找地址：&运算符

* 指针（pointer）是c语言最重要的概念之一，==用于存储变量的地址==
  * 如果主调函数不使用`return`返回的值，则必须通过地址才能修改主调函数中的值
* 一元运算符`&`给出变量的存储地址。如果`pooh`是变量名，那么`&pooh`就是变量的地址
  * 可以把地址看作是变量在内存中的位置（把内存看作一个大数组，地址就是内存数组的索引）
* C语言中输出地址的转换说明是`%p`
  * `printf("%d, %p\n", pooh, &pooh);`
* 函数调用时把实际参数的值传递给形式参数时==只传递了值==，涉及的两个变量地址并不相同
  * 每个C语言的函数都有自己的变量（命名空间）



## 更改主调函数中的变量

* 有时需要在一个函数中更改其他函数的变量
* 用`return`语句只能把被调函数中的一个值传回主调函数。如果要传回多个值，需要使用指针。



## 指针简介

* 从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址
* 要创建指针变量要先声明指针变量的类型。需要用到间接运算符`*`



### 间接运算符 *

* 间接运算符`*`是一元运算符，与二元乘法运算符的符号相同但语法功能不同。有时也称为解引用运算符
* 假设已知`ptr`指向`bah`：`ptr = &bah;`，可以使用`*`找出储存在`bah`中的值：`val = *ptr;`
  * 语句`ptr = &bah;`和`val = *ptr;`放在一起相当于下面的语句：
  * `val = bah;`
* `*`后跟一个指针名或地址时，`*`给出储存在指针指向地址上的值。

### 声明指针

* 声明指针变量时==必须指定指针所指向变量的类型==，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。

* 另外，程序==必须知道储存在指定地址上的数据类型==

  ```c
  int* pi;
  char* pc;
  float* pf, * pg;
  ```

* `*`和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。

* pc指向的值（*pc）是char类型。pc本身是什么类型？我们描述它的类型是“指向char类型的指针”。

* pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，==不要把指针认为是整数类型==。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。

* 所以，==指针实际上是一个新类型，不是整数类型==。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。



### 使用指针在函数间通信

* 将指针变量作为形参，把变量的地址作为实参传入被调函数

  ```c
  /* swap3.c -- 使用指针解决交换函数的问题 */
  #include　<stdio.h>
  
  void interchange(int * u, int * v);
  int　main(void){
      int　x　=　5,　y　=　10;
      printf("Originally　x　=　%d　and　y　=　%d.\n",　x,　y);
      interchange(&x, &y);　 // 把地址发送给函数
      printf("Now　x　=　%d　and　y　=　%d.\n",　x,　y);
      return　0;
  }
  void interchange(int * u, int * v){
      int　temp;
      temp = *u;　　// temp获得 u 所指向对象的值
      *u = *v;     // 找到内存地址进行交换
      *v = temp;
  }
  ```

* 函数调用：`interchange(&x, &y);`
  * 该函数传递的不是 `x`和`y `的值，而是它们的地址。在函数原定和定义中的形式参数`u`和`v`将把地址作为它们的值，因此应将它们声明为指针
  * `u`的值是`&x`，所以`u`指向`x`。这意味着用`*u`即可表示x的值
* 使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们。
* 一般而言，可以把变量相关的两类信息(值和地址)传递给函数。
  * 如果是`func1`形式的函数调用，那么传递的是`x`的值
    * `func1(x);`
  * 如果是`func2`形式的函数调用，那么传递的是`x`的地址
    * `func2(&x);`
  * 第一种形式要求函数定义中的形式参数必须是一个与`x`的类型相同的变量：
    * `int func1(int num)`
  * 第二种形式要求函数定义中的形式参数必须是一个指向`x`类型的指针：
    * `int func2(int* ptr)`

* 如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第2种形式的函数调用
* C语言没有引用变量，C++有引用变量 ([c++引用变量](https://www.runoob.com/cplusplus/cpp-references.html))

* 通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。
* 编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。
* **地址就是变量在计算机内部的名称。**

* 在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&运算符访问地址，通过*运算符获得地址上的值。
* 普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。

* **使用&、*和指针可以操纵地址和地址上的内容**

* 被调函数一般不会改变主调函数中的变量，如果要改变，应使用指针作为参数。**如果希望把更多的值传回主调函数，必须这么做。**



# 第十章 数组和指针

* 数组能高效便捷地处理大量彼此相关的数据
* 数组和指针关系密切。



## 数组

* 变量名 + [] 表示该变量是一个数组（指针变量），[]内的值表示数组长度

### 初始化数组

* 只储存单个值的变量有时也称为标量变量
  * 初始化：`int fix = 1;`
* 数组初始化：
  * `int powers[8]={1,2,3,6,8,16,32,64};`
  * 数组`power`存储整型的值，长度为8（最大下标为7，长度减一）
  * 用以**逗号分隔**的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（powers[0]），以此类推。
  * 数组的长度可以用整数和宏定义的常量表示，**不可以用变量**（C99以后可以）
  * 推荐使用符号常量表示数组大小
  * 创建只读数组：使用 `const`关键字
    * `const int days[MONTHS]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};`

* 如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值（不同的compiler并不相同，可能是0）；但是，如果部分初始化数组，剩余的元素就会被初始化为0。
* 可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数
  * `const　int　days[]　=　{　31,　28,　31,　30,　31,　30,　31,　31,　
    30,　31　};`
  * **这种用法必须在初始化时就赋值给数组元素，不能这样声明一个空数组**
    * `int arr[]; //这种声明是错误的`
  * 要声明一个空数组，**必须给出其长度**
    * `int arr[LENGTH]; //合法` 
* 可以用`sizeof arr / sizeof arr[0]`的方法得到数组元素的个数（数组长度）。其中的被除数可以替换成arr的类型（建议使用arr[0]）。
* 自动计数（即省略数组长度）的弊端：无法察觉初始化列表中的项数有误



### 指定初始化器

* 利用该特性可以初始化指定索引的数组元素，也可以更改之前初始化过的数组元素

* 对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。

  ```c
  #include <stdio.h>
  #define N 12
  int main(void){
  	int arr[N] = {[5] = 100};
      for (int i = 0; i < N; i++)
          printf("%d\n", arr[i]);
  	return 0;
  }
  ```

  * 上面一段代码的输出为

  ![image-20201221195253121](note%20for%20C.assets/image-20201221195253121.png)

  ```c
  #include <stdio.h>
  #define N 12
  int main(void){
  	int arr[N] = {1, 2, [5] = 100, 6, [0] = 20};
      for (int i = 0; i < N; i++)
          printf("%d\n", arr[i]);
  	return 0;
  }
  ```

  * 上面一段代码的输出为

  ![image-20201221195435183](note%20for%20C.assets/image-20201221195435183.png)

* 以上输出揭示了指定初始化器的两个重要特性。
  * 第一，如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：[5] = 100, 6。那么**后面这些值将被用于初始化指定元素后面的元素**。也就是说，在days[5]被初始化为100后，days[6]将被初始化为6。
  * 第二，**如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化**。初始化列表开始时把days[0]初始化为1，但是days[0]又被后面的指定初始化[0] = 20初始化为20。

* 如果未指定元素大小会怎样？
  `int stuff[] = {1, [6] = 23};　　　　 //会发生什么？`
  `int staff[] = {1, [6] = 4, 9, 10};　//会发生什么？`
  
* 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为0～6；而staff数组的元素比stuff数组多两个（即有9个元素）。
  
* C 不允许把数组作为一个单元赋给另一个数组，**除初始化以外也不允许使用花括号列表的形式赋值。**



## 多维数组

* 即数组的数组
* 数组声明：
  * `float rain[5][12];`
    * 理解该声明的一种方法：`rain`是一个内含5个元素的数组，每个元素的类型是`float[12]`。也就是说，`rain`的每个元素本身都是一个内含12个float类型值的数组
  * 如果 `rain[0]`是一个数组，那么它的首元素就是` rain[0][0]`，第 2 个元素是`rain`
  * `[0][1]`，以此类推。简而言之，数组`rain`有5个元素，每个元素都是内含12个`float`类型元素的数组，`rain[0]`是内含12个`float`值的数组，`rain[0][0]`是一个`float`类型的值。假设要访问位于2行3列的值，则使用`rain[2][3]`（记住，数组元素的编号从0开始，所以`rain[2]`指的是第3行）。



![image-20201221211518227](note%20for%20C.assets/image-20201221211518227.png)

* 气象分析程序

  * 目标：计算每年的总降水量、年平均降水量和月平均降水量

  ```c
  /* rain.c -- 计算每年的总降水量、年平均降水量和5年中每月的平均降水量*/
  
  #include <stdio.h>
  #define MONTHS 12
  #define YEARS 5
  
  int main(void){ //用2010~2014年的降水量数据初始化数组
      const float rain[YEARS][MONTHS] =
      {
          {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
          {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
          {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.4, 8.4},
          {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
          {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
      };
      int year, month;
      float subtot, total;
      printf("YEAR RAINFALL (inches)\n");
      for (year = 0, total = 0; year < YEARS; year++){ //分别计算每年中各个月的降水量总和。按行求和
          for (month = 0, subtot = 0; month < MONTHS; month++)//注意每次都让subtot置零，节省存储空间
              subtot += rain[year][month]; //子循环内只有这一条语句
          printf("%5d  %15.1f\n", 2010 + year, subtot);
          total += subtot; //5年的总降水量
          
      }
      printf("\nThe yearly aberage is %.1f inches.\n\n", total / YEARS);
      printf("MONTHLY AVERAGES:\n\n");
      printf(" Jan Feb Mar Apr May Jun Jul Aug Sep Oct");
      printf(" Nov Dec\n");
      for (month = 0; month < MONTHS; month ++){ //分别计算不同月份5年的总降水量。按列求和
          for (year = 0, subtot = 0; year < YEARS; year++)
              subtot += rain[year][month];
          printf("%4.1f", subtot / YEARS);        
      }
      printf("\n");
      return 0;
  }
  ```

* 程序中两次使用了嵌套`for`循环（两次嵌套）

  * 无论是哪一次的嵌套循环，基础的求和变量都是`rain[year][month]`。只是不同的循环次序据定了最终求得的结果
  * 对一个矩阵$A$的操作就是围绕着行和列，处理的基本元素都是$A_{ij}$



### 初始化二维数组

* 初始化二维数组是建立在初始化一维数组的基础上。
  * 一维数组初始化：`sometype arr1[5][12]={val1, val2, val3, val4, val5};`
* 如果`arr1`是二位数组，那么相应的`val1`就是一个由多个数值构成的数值列表{ }
  * 类比到矩阵，`arr[m][n]={{}, {}, ..., {}}`中有m个花括号(m个行向量)，每个花括号中又有n个数值元素（n维行向量）
* 前面讨论的数据个数和数组大小不匹配的问题同样适用于这里的每一行。也就是说，如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。
* 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。==不推荐==
* 但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。下图演示了这种初始化数组的方法。

![image-20201222160314083](note%20for%20C.assets/image-20201222160314083.png)



### 其他多维数组

略

## 指针和数组

**数组名是数组首元素的地址**

* **指针提供一种以符号形式使用地址的方法。**
* 指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。**因此，使用指针的程序更有效率。**
* 指针能有效地处理数组。我们很快就会学到，**数组表示法其实是在变相地使用指针。**

* 如果`flizny`是一个数组，下面的语句成立：

  *  `flizny == &flizny[0]; // 数组名是该数组首元素的地址`
  * `flizny` 和`&flizny[0]`都表示数组首元素的内存地址（`&`是取地址运算符）。两者都是常量，在程序的运行过程中，**内存地址不会改变。**但是，**可以把它们赋值给指针变量，然后可以修改指针变量的值**

  ```c
  /* pnt_add.c -- 指针地址*/
  #include <stdio.h>
  #define SIZE 4
  
  int main(void){
      short dates[SIZE];
      short* pti;
      short index;
      double bills[SIZE];
      double* ptf;
      pti = dates;  //dates == &dates[0]，把数组首元素的地址以数组名的形式赋值给指针pti
      ptf = bills;
      printf("%23s  %12s\n", "short", "double");
      for (index = 0; index < SIZE; index++)
          printf("pointers + %d: %10p %10p\n", index, pti + index, ptf + index); //pti + i == dates[i]; ptf + i == bills[i]
      return 0;    
  }
  ```

* 在C语言中，**指针加1是指增加一个存储单元**。对数组而言，这意味着加1后的地址是下一个元素的地址，因此**增加的字节大小与数组的类型密切相关**

  * 这是为什么**必须声明指针所指向对象类型**的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则`*pt` 就无法正确地取回地址上的值）。

![image-20201222162214777](note%20for%20C.assets/image-20201222162214777.png)

* 指针的值是它所指向对象的地址。在指针前面使用`*`运算符可以得到该指针所指向对象的值

* 下面的等式体现了C语言的灵活性：
  * `dates + 2 == &date[2]　　　 // 相同的地址`
  * `*(dates + 2) == dates[2]　 // 相同的值`
* 以上关系表明了数组和指针的关系十分密切，**可以使用指针标识数组的元素和获得元素的值**。
* 从本质上看，同一个对象有两种表示法。实际上，C语言标准在描述数组表示法时确实借助了指针。
* 也就是说，定义`ar[n]`的意思是`*(ar + n)`。可以认为`*(ar + n)`的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值”。

* 不要混淆` *(dates+2)`和`*dates+2`。间接运算符`（*）`的优先级高于`+`，所以`*dates+2`相当于`(*dates)+2`



## 函数、数组和指针

* 假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为`marbles`的`int`类型数组。应该如何调用该函数？也许是下面这样：
  `total = sum(marbles); // 可能的函数调用`
  那么，该函数的原型是什么？记住，**数组名是该数组首元素的地址**，所以实际参数`marbles`是一个储存`int`类型值的**地址**，应把它赋给一个指针形式参数，即该形参是一个指向`int`的指针(形参最关键的就是声明待传入数据的类型)：

  `int sum(int * ar); // 对应的函数原型`

* 总结：处理数组的函数其实参应该是数组首元素的地址（数组名），其形参应该是一个指针变量

* `sum()`从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。

  * 第一种方法是，在被调函数代码中写上固定的数组大小。（如在循环中设定循环次数等于数组长度）有比较大的限制，只能处理固定数量的元素。
  * 另一个比较灵活的方法是把数组大小作为第2个参数：
    * `int sum(int * ar, int n)　　　 // 更通用的方法`
    * 这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。

* 关于函数的形参，还有一点要注意。**只有在函数原型或函数定义头中**，才可以用`int ar[]`代替`int * ar`

  * 因为`int ar[]`只是一个数组的首元素地址，`int * ar`则还有可能是一个数值的地址而非数组

* 注意数组的大小(size)与指向数组的指针大小(size)并不相同。数组的大小不是固定的，指向数组的指针大小在特定系统中则是固定的

  ```c
  int marbles[10]={20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
  answer = sum(marbles, 10);
  //sizeof marbles == 40
  int sum(int ar[], n)
  //sizeof ar == 8，因为这里的ar[]其实就是一个地址，sizeof ar返回的是地址类型的大小
  ```

  * `marbles`是一个数组，` ar`是一个指向`marbles`数组首元素的指针，利用C中数组
    和指针的特殊关系，可以用数组表示法来表示指针`ar`。

### 使用指针形参

* **函数要处理数组必须知道何时开始、何时结束。**`sum()`函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。

* 但是这并不是给函数传递必备信息的唯一方法。**还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。**

  * 数组结束处 == 数组开始处 + 数组长度
  * 这种使用方法是直接将数组的地址作为索引，配合`*`运算符进行取值

  ```c
  /* pnt_add.c -- 指针地址*/
  #include <stdio.h>
  #define SIZE 10
  
  int sum(int*, int*);
  int main(void){
      int ar[SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  	printf("The sum of ar is %d", sum(ar, ar + SIZE)); //ar + SIZE指向的位置实际上在数组最后一个元素的后面，属于“越界”指针。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。
      return 0;    
  }
  
  int sum(int* start, int* end){
  	int total = 0;
  	while(start < end){
  		total += *start; //取出该地址的值并累加
  		start++;         //递增地址的值
  	} //将地址作为索引，代码简洁
  	return total;
  }
  ```

  * 指针`start`开始指向`marbles`数组的首元素，所以赋值表达式`total += *start`把首元素（1）加给`total`。然后，表达式`start++`递增指针变量`start`，使其指向数组的下一个元素。
  * 因为`start`是指向`int`的指针，`start`递增1相当于其值递增`int`类型的大小。

* 处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。

* 指针的类型其实就是给指针一个单位，告知了指针+1在内存中移动的位置



## 指针操作

* `%p`：指针变量转换说明
* `%tp`：地址差值转换说明
* 赋值 `=`
* 解引用 `*`
* 取址 `&`
  
  * 指针变量的值是它所指向的变量的地址，而指针变量本身也可以用`&`进行取地址
* 指针与整数相加
  
  * 可以使用`+`运算符把指针与整数相加，或整数与指针相加。无论哪种情况，**整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。**
* 递增指针：
  
  * 递增指向数组元素的指针可以让该指针移动至数组的下一个元素。
* 指针减去一个整数：
  
  * 可以使用`-`运算符从一个指针中减去一个整数。**指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。**
* 递减指针

指针的加减其实就说明了指针与数组的密切联系

* 指针求差
  
  * 可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。
  
* 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。

* **千万不要解引用未初始化的指针**

  * `int * pt;// 未初始化的指针
    *pt = 5;　　　// 严重的错误`
  * 第2行的意思是把5储存在`pt`指向的位置。但是`pt`未被初始化，其值是一个随机值，所以不知道5将储存在何处。指针的初始化即分配内存地址

* 切记：创建一个指针时，系统只分配了储存指针本身的内存(指针本身的地址)，并未分配储存数据的内存。因此，**在使用指针之前，必须先用已分配的地址初始化它。**（即给指针一个确定的存放值的地址）

  * 可以用一个现有变量的地址初始化该指针

  * 还可以使用`malloc()`函数先分配内存

  * 什么是`malloc()`?[参考](https://zhuanlan.zhihu.com/p/105090421)（需要`#include <stdlib.h>`）

    * 总结：`malloc`的意义是向 **堆区** 要了一块`sizeof(int) * N` 这么大的空间，即在不支持C99的编译器上实现`arr[N]`的功能

    * 使用方法：`int* arr = (int*)malloc(sizeof(int) * N)`

      * 需要根据实际需要的类型对`malloc`的返回结果进行类型转换

    * 使用`malloc()`完毕后要使用`free`释放生成的指针（固定动作）

      * `free(arr)`

    * 例子：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      
      int main(void) {
      
          int i = 0;
          int N = 0;
          int* arr;
      
          printf("请输入数组的大小\n");
          scanf("%d", &N);
      
          arr = (int*)malloc(sizeof(int) * N);
      
          printf("请输入%d个数\n", N);
          for (i = 0; i < N; i++)
              scanf("%d", &arr[i]);
      
          for (i = 0; i < N; i++)
              printf("%d ", *(arr + i)); //arr[i], *(&arr[0] + i)均可
          free(arr);
          return 0;
}
      ```
      



* 基于对指针的操作，C程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等
* 指针的第1个基本用法：在函数间传递信息
  * 如果希望在被调函数中改变主调函数的变量，必须使用指针（传递变量的地址）
* 指针的第2个基本用法：用在处理数组的函数中



## 保护数组中的数据

* 编写一个处理基本类型（如，`int`）的函数时，要选择是传递`int`类型的值还是传递指向`int`的指针。

* 通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针
* **对于数组别无选择，必须传递指针**
* 如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。
* 如果把数组的地址传递给函数，那么让函数直接处理原数组则效率要高。

* 传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。
* 但是，处理数组的函数通常都需要使用原始数据，**因此这样的函数可以修改原数组**
  * 处理数组的函数通常除了传入数组地址，还要传入数组长度



### 对形式参数使用 const

* 如果函数的意图不是修改数组中的数据内容，那么在**函数原型和函数定义**中声明形式参数时应使用关键字const。

  ```c
  int sum(const int ar[], int n); /* 函数原型 */
  int sum(const int ar[], int n) /* 函数定义 */
  {
      int total = 0;
      for (i = 0; i < n; i++)
          total += ar[i];
      return total;
  }
  ```

* 以上代码中的`const`告诉编译器，该函数不能修改`ar`指向的数组中的内容。如果在函数中不小心使用类似`ar[i]++`的表达式，编译器会捕获这个错误，并生成一条错误信息。



### const的其他内容

* 使用`#define`指令可以创建类似`const`功能的符号常量，但是`const`的用法更加灵活。可以创建`const`数组、`const`指针和指向`const`的指针

* 最常见的用法时用来保护数据，不能随意修改，即使是指针

  * 相当于**只读**

* 看下面的例子

  ```c
  double rates[5] = {88.99, 100.12, 59.45, 189.11, 340.5};
  const double* pd = rates; // pd指向数组的首元素。const意味着不可以通过指针pd来修改rates中的内容，但是可以修改pd本身
  
  *pd = 29.89; //不允许（*pd即rates的首元素rates[0]）
  pd[2] = 222.22; //相当于rates[2]，不允许
  rates[0] = 99.99; //允许
  pd++; //允许，让指针指向别处
  ```

* 指向` const` 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。（只是访问他们）

* 关于指针赋值和`const`需要注意一些规则。首先，把`const`数据或非`const`数据的地址初始化为指向`const`的指针或为其赋值是合法的：

  ```c
  double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
  const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
  const double*pc = rates; //有效
  pc = locked; //有效
  pc = &rates[3]; //有效
  
  double* pnc = rates; //有效
  pnc = locked; //无效  const数据的地址只能传给const的指针
  pnc = &rates[3]; //有效
  ```

* 总结：

  * `const`数据的地址和非`const`数据的地址都可以传给`const`的指针
  * `const`数据的地址不能传给非`const`的指针（C中会给出警告，C++则不允许）

* 对函数的形参使用`const`不仅能保护数据，还能让函数处理`const`数组。

* 不能把`const`类型的数组名传递给非`const`的形参。这样导致的结果是未定义的。

* `const`还可以初始化一个不能指向别处的指针，**关键是指针的位置**

  ```c
  double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
  double* const pc = rates; // pc指向数组的开始，且只能指向rates[0]
  pc = &rates[2];           //不允许，因为该指针不能指向别处
  *pc = 92.99;              // 可以，更改rates[0]的值
  ```

* 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地
  址。

* 最后，在创建指针时还可以使用`const`两次，该指针既不能更改它所指
  向的地址，也不能修改指向地址上的值：

  ```c
  double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
  const double* const pc = rates; // pc指向数组的开始
  pc = &rates[2];           //不允许
  *pc = 92.99;              //不允许
  ```





## 指针和多维数组

* 处理多维数组的函数要用到指针

  * 多维数组即指针的指针

* 牢记，**数组名是该数组首元素的地址**。 `arr_num == &arr_num[0]`

* 假设有下面的声明：

  ```c
  int zippo[4][2];  /* 内含4个2维的 int 数组的数组。一个int占4字节，一个二维int占8字节，四个二维占32字节。一个字节就是一个16进制数*/
  ```

  * `zippo`的值等于`&zippo[0]`。`zippo[0]`本身是一个内含两个整数的数组，因此`zippo[0]`的值等于`&zippo[0][0]`

  * `zippo[0]`是一个占用一个`int`大小对象的地址（`&zippo[0][0]`），`zippo`是一个占用两个`int`大小对象的地址（`&zippo[0]`）。由于这个整数和内含两个整数的数组都开始于同一个地址，所以`zippo`和`zippo[0]`的值相同。**但是单位不同**

    * **不要把指针当成内存地址**，指针指向内存地址

    ![image-20201225195335298](note%20for%20C.assets/image-20201225195335298.png)

  * **给指针或地址加1，其值会增加对应类型大小的数值。**在这方面，`zippo`和`zippo[0]`不同，因为`zippo`指向的对象占用了两个`int`大小，而`zippo[0]`指向的对象只占用一个`int`大小，因此`zippo + 1`和`zippo[0] + 1`的值不同

    ![image-20201225195928816](note%20for%20C.assets/image-20201225195928816.png)

* 这里zippo + 1是指向4维数组的指针 + 1，存储4个int的数组占用空间为16字节，因此刚好从FF00到FF10，进了1位16进制数
* zippo[0] + 1 则是指向一个int的指针 + 1，即4个字节

* 解引用一个指针（在指针前使用`*`运算符）或在数组名后使用**带下标**的`[]`运算符，得到引用对象代表的值。
* 因为`zippo[0]`是该数组首元素（`zippo[0][0]`）的地址，所以 `*(zippo[0])`表示储存在`zippo[0][0]`上的值（即一个`int`类型的值）。与此类似，`*zippo`代表该数组首元素（`zippo[0]`）的值，但是`zippo[0]`本身是一个`int`类型值的地址。该值的地址是`&zippo[0][0]`，所以`*zippo`就是`&zippo[0][0]`。
* 对两个表达式应用解引用运算符表明，`**zippo`与`*&zippo[0][0]`（`*zippo[0]`）等价，这相当于`zippo[0][0]`，即一个`int`类型的值。
* 简而言之，`zippo`**是地址的地址，必须解引用两次才能获得原始值**。
* 地址的地址或指针的指针是就是**双重间接**（double indirection）的例子。

* 尝试解释如下代码：

  ```c
  /* zippo1.c -- zippo的相关信息 */
  #include <stdio.h>
  
  int main(int argc, char* argv[]){
      int zippo[4][2] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
      printf(" zippo = %p, zippo + 1 = %p\n", zippo, zippo + 1);
      printf("zippo[0] = %p, zippo[0] + 1 = %p\n", zippo[0], zippo[0] + 1);
      printf(" *zippo = %p, *zippo + 1= %p\n", *zippo, *zippo + 1);
      printf("zippo[0][0] = %d\n", zippo[0][0]);
      printf(" *zippo[0] = %d\n", *zippo[0]);
      printf(" **zippo = %d\n", **zippo);
      printf("   zippo[2][1] = %d\n", zippo[2][1]);
      printf("*(*(zippo + 2) + 1) = %d\n", *(*(zippo + 2) + 1));
      return 0;
  }
  ```

  输出结果如下：

  ​	![image-20201225202040657](note%20for%20C.assets/image-20201225202040657.png)

* `zippo[0]`和`*zippo`完全相同，`zippo[0][0]`和`*(*zippo)`完全相同
* `zippo[i][j]`和`*(*(zippo + i) + j)`完全相同

![image-20201228220019778](note%20for%20C.assets/image-20201228220019778.png)

* 如果程序恰巧使用一个指向二维数组的指针，而且要通过该指针获取值时，**最好用简单的数组表示法**，而不是指针表示法。

![image-20201228220118566](note%20for%20C.assets/image-20201228220118566.png)



### 指向多维数组的指针

* 指向二维数组`zippo`的指针`pz`不能简单的声明为`int`类型，必须指向一个内含两个`int`类型值的数组，声明如下：

  `int(*pz)[2]; // pz指向一个内含两个int类型值的数组`

  * 以上代码把`pz`声明为指向**一个数组**的指针，该数组内含两个`int`类型值。使用圆括号的原因是`[]`的优先级高于`*`

  `int *pax[2]; // pax是一个内含两个指针元素的数组，每个元素都指向int的指针`

* 假设有如下代码：

  ```c
  int zippo[4][2]={{2, 4}, {6, 8}, {1, 3}, {5, 7}};
  int(*pz)[2]; // int **pz 是否有相同的功能？不行。指向数组的指针与指向指针的指针并不相同
  pz = zippo;//把首元素的地址传给pz
  ```

* 那么有

  ```c
  zippo[m][n] == *(*(zippo + m) + n);
  pz[m][n] == *(*(pz + m) + n);    
  ```

* 虽然`pz`是一个指针，不是数组名，但是也可以使用`pz[2][1]`这样的写法



### 指针的兼容性

* 指针之间的赋值比数值类型之间的赋值要严格，不同类型的指针之间不能互相赋值

* 不能把`const`数据的地址赋值给非`const`的指针，这样就可以修改`const`的数据了。可以把非`const`数据的地址赋值给`const`的指针，但是这样的赋值**在进行两级解引用时也不安全**

* 原因在于指针之间的互相赋值其实是更改其定位到的内存地址，只要内存的内容变了，那么在解引用任何指向该内存的指针都会改变。

* 更改指针的值其实是移动指针在内存中的指向

  ```c
  const int**pp2;
  int*p1;
  const int n = 13;
  pp2 = &p1; //允许，但此时将pp2的指向定位到了&p1，使得const限定符失效
  *pp2 = &n; //有效，两者都声明为const(其实是骗过了compiler)，但是这将导致p1指向n，因为此时的*pp2和p1是定位在同一个内存地址的指针
  *p1 = 10; //有效，但这将改变n的值，使得const限定符失效
  ```



**C const 和 C ++ const**

* C和C++中`const`的用法很相似，但是并不完全相同

  * C++允许在声明数组大小时使用`const`整数，而C却不允许
  * C++的指针赋值检查更严格

  ```c
  const int y;
  const int*p2 = &y;
  int*p1;
  p1 = p2; //C++中不允许这样做，但是C可能只是给出警告
  ```

  

### 函数和多维数组

* 要编写处理二维数组的函数，首先要正确地理解指针才能写出声明函数地形参。在函数体中，通常使用**数组表示法**进行相关操作。

* 考虑如下的程序

  ```c
  int junk[3][4]={{2, 3, 5, 8}, {3, 5, 6, 9}, {12, 10, 8, 6}};
  int i, j;
  int total = 0;
  for (i = 0; i < 3; i++)
      total += sum(junk[i], 4); // junk[i] 是一维数组，其元素也是数组（地址）
  ```

* 如果`junk`是二维数组，那么`junk[i]`就是一维数组，**可将其视为二维数组的一行**。

* 这里`sum`函数计算二维数组的每行的纵隔，然后`for`循环再把每行的总和加起来。

* 这种方法**无法记录行和列的信息**

* 该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组`junk`是一个内含3个数组元素的数组，每个元素是内含4个`int`类型值的数组（即`junk`是一个3行4列的二维数组）。这表明`junk`是一个指向数组（内含4个`int`类型值）的指针。可以这样声明函数的形参：

  ```c
  void somefunction(int(*pt)[4]);
  ```

* 另外，**当且仅当`pt`是一个函数的形式参数时**，可以这样声明：

  ```c
  void somefunction(int pt[][4])
  ```

  * 空的方括号表示`pt`是一个指针。这样的变量稍后可以用作相同方法作为`junk`。

  ```c
  //array2d.c -- 处理二维数组的函数
  
  #include <stdio.h>
  #define ROWS 3
  #define COLS 4
  
  void sum_rows(int ar[][COLS], int rows);
  void sum_cols(int [][COLS], int);   //省略形参名
  int sum2d(int(*ar)[COLS], int rows);  //另一种语法
  
  int main(void)
  {
      int junk[ROWS][COLS]={
          {2, 4, 6, 8},
          {3, 5, 7, 9},
          {12, 10, 8, 6}
      };
      sum_rows(junk, ROWS);
      sum_cols(junk, ROWS);
      printf("Sum of all elemrnts = %d\n", sum2d(junk, ROWS));
      return 0;
  }
  
  void sum_rows(int ar[][COLS], int rows)
  {
      int r;
      int c;
      int tot;
      for (r = 0; r < rows; r++)
      {
          tot = 0;
          for (c = 0; c < COLS; c++)
              tot += ar[r][c];
          printf("row %d:sum = %d\n", r, tot);
      }
  }
  
  void sum_cols(int ar[][COLS], int rows)
  {
      int r;
      int c;
      int tot;
      for (c = 0; c < COLS; c++)
      {
          tot = 0;
          for (r = 0; r < rows; r++)
              tot += ar[r][c];
          printf("col %d: sum = %d\n", c, tot);
      }
  }
  
  int sum2d(int ar[][COLS], int rows)
  {
      int r;
      int c;
      int tot = 0;
      for (r = 0; r < rows; r++)
      {
          for (c = 0; c < COLS; c++)
              tot +=ar[r][c];
      }
      return tot;
  }
  ```
  
* 程序把数组名`junk`和符号常量`ROWS`作为参数传递给函数。每个函数都把`ar`视为内含数组元素的数组。列数内置在函数体中（在函数声明和定义头中以宏定义的形式给出），但是行数是靠函数传递得到的，如果传入的函数的行数是12，那么函数要处理的就是12$\times$4的数组。
* `int sum2(int ar[][], int rows); //错误地声明`
* `int sum2(int ar[][4], int rows); //有效声明`
* C有一个`typedef`机制，允许程序员为现有类型创建别名
  
  * `typedef double real`，这样`real`就是`double`的别名
* 一般而言，声明一个指向N为数组的指针时，只能省略最左边方括号中的值，因为**第一对方括号只用于表明这是一个指针**，而其他的方括号则用于描述指针所指向数据对象的类型
  
  * 注意这里说的是指向数组的指针忽略方括号而不是数组忽略



## 变长数组（VLA）

* 在处理二维数组的函数中为何只把数组的行数作为函数的形参，而列数却内置在函数体内？
  * 因为C规定（C99之前）数组的维数必须是常量，不能用变量代替`COLS`
* C99新增了变长数组，允许使用变量表示数组的维度
* 变长数组必须是自动存储类别，无论是在函数中声明还是作为函数形参声明，都不能使用`static`或`extern`存储类别说明符
* 不能在声明中初始化VLA
* 注意：变长数组在创建时可以用变量来指定数组的维度，但是一旦创建以后，它的大小就保持不变
* VLA允许动态内存分配
  * 动态内存分配：可以在程序运行时指定数组的大小
  * 静态内存分配：在编译时确定数组的大小

* 以变长数组作为形参的函数既可处理传统C数组，也可处理变长数组。
* 变长数组作为形参必须在声明之前声明数组维度的形参。如果要忽略原型中的形参名，必须用星号`*`来代替省略的维度
  * `int func(int, int, int ar[*][*]);// ar是一个变长数组，省略了维度形参的名称`



## 复合字面量

* 假设给带`int`类型形参的函数传递一个值，可以传递`int`类型的变量，也可以传递`int`类型的常量。

* 在C99之前，对于带数组形参的函数可以传递数组，但没有等价的数组常量

* C99新增了复合字面量(compound literal)

* 字面量是指除符号常量（`const`限定或宏定义的）以外的常量
  * 5是`int`类型的字面量
  * 81.3是`double`类型的字面量
  * 'Y'是`char`类型的字面量
  * "elephant"是字符串字面量
  
* 复合字面量是指代表数组和结构内容的字面量，**而且是匿名的，必须在创建的同时使用它**

* 对于数组，复合字面量类似数组初始化列表，前面是**用括号括起来的类型名**。
  * 普通的数组声明:`int diva[2]={10,20};`
  * 下面的复合字面量创建了一个和diva数组相同的匿名数组：`(int[2]){10,20}`

* 初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：

  * `(int[]){50, 20, 90}`

* 使用复合字面量的方法：

  * 使用指针记录地址

  ```c
  int*pt1;
  pt1 = (int[2]){10,20};
  ```

  * 作为实际参数传递给带有匹配形式参数的函数,这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法：

  ```c
  int sum(const int ar[], int n);
  ...
  int total3;
  total3 = sum((int[]){4,4,4,5,5,5},6);
  ```

* 可以把这种用法应用于二维数组或多维数组。

  ```c
  int (*pt2)[4];　　 // 声明一个指向二维数组的指针，该数组内含2个数组元素，每个元素是内含4个int类型值的数组
  pt2　=　(int　[2][4])　{　{1,2,3,-9},　{4,5,6,-8}　};
  ```



* 记住，复合字面量是提供**只临时需要的值**的一种手段。
* 复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。
* 也就是说，复合字面量的定义在最内层的花括号中。
* 要处理数组，必须知道数组的起始位置与终止位置。普通的数组是传递给函数首元素地址和数组长度（或者首尾元素的地址，总之需要两个参数），字符串数组比较特殊，不需要传递数组长度，因为字符串末尾有空字符



# 第十一章 字符串和字符串函数

## 表示字符串和字符串I\O

* 字符串是以空字符(\\0)结尾的`char`类型==数组==。由于字符串十分常用，所以C提供了许多专门用于处理字符串的函数

* 下面的程序时字符串的几种表示方式：

  ```c
  // strings1.c
  
  #include <stdio.h>
  #define MSG "I am a symbolic string constant."
  #define MAXLENGTH 81
  
  int main(int argc, char *argv[])//这里argv[]存的的元素是字符串而非字符，因此用*argv[](or **argv)来表示指向字符串（数组、指针）的指针
  {
      char words[MAXLENGTH] = 'I am a string in an array.';
      const char *pt1 = "Something is pointing at me.";
      puts("Here are some strings:");
      puts(MSG);
      puts(words);
      puts(pt1);
      words[8] = 'p';
      puts(words);
      return 0;
  }
  ```

  * `puts()`函数也属于`stdio.h`系列的输入/输出函数。但是，与`printf()`不同的是，`puts()`函数只显示字符串，而且自动在显示的字符串末尾加上换行符。



### 在程序中定义字符串

* 定义字符串时，程序应该确保有足够的空间存储字符串

1. 字符串字面量（字符串常量）

   * 用引号括起来的内容称为字符串字面量。如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。

   * 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠(\\)

   * 字符串常量属于静态存储类别，这说明**如果在函数中使用字符串常量，该字符串只会被储存一次。用双引号括起来的内容被视为指向该字符串储存位置的指针**

     ```c
     /* strptr.c -- 把字符串看作指针 */
     
     #include <stdio.h>
     
     int main(void)
     {
         printf("%s, %p, %c\n", "We", "are", *"space farers");//注意把双引号括起来的内容当作一个数组名、指针
         return 0;
     }//输出：We, 0X100000f61, s
     ```

2. 字符串数组和初始化

   * 定义字符串数组时，必须让编译器知道需要多少空间
     * 通常让编译器确定数组的大小很方便
     * `consr char m2[] = "If you can't think of anything, fake it"`
   * 让编译器计算数组的大小只能用在初始化数组时。
   * 如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由
     整型常量组成的表达式。
   * 区分字符串与字符数组：前者有'\\0'而后者没有
   * 还可以使用指针表示法创建字符串：
     * `const *pt1 = "Something is pointing at me.";`
     * `const char ar1[] = "Something is pointing at me.";`
     * 以上两种声明几乎相同，`pt1`和`ar1`都是该字符串的地址。但是这两种形式并不完全相同。

3. 数组和指针

   * 数组形式和指针形式有何不同？
     * **在数组形式中，`ar1`时地址常量**，不能更改`ar1`。在这种情况下，字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在`ar1`数组中的字符串。
     * 指针形式中，`pt1`是指向静态内存位置的指针变量，它的值可以改变。字符串只是以字面量的形式存储在静态内存中
     * **字符串字面量被视为`const`数据。**由于`pt1`指向这个`const`数据，所以应该把`pt1`声明为指向`const`数据的指针。这意味着不能用`pt1`改变它所指向的数据，但是仍然可以改变`pt1`的值（即，`pt1`指向的位置）。
   * 总之，**初始化数组把静态存储区的字符串拷贝到数组中，数组名是一个地址常量（相当于双引号括起的内容）；而初始化指针只把静态存储区的字符串地址拷贝给指针变量。**

4. 数组和指针的区别

   * 假设有下面两个声明：
     * `char heart[] = "I love Tillie!";`
     * `const char *head = "I love Millie!";`
   * 两者的主要区别是：数组名`heart`是常量，而指针名`head`是变量

5. 字符串数组

   * 创建字符串数组的方法：
     * 指向字符串的指针数组
     * `char`类型的数组的数组

   ```c
   // arrchar.c -- 指针数组，字符串数组
   #include <stdio.h>
   #define SLEN 40
   #define LIM 5
   
   int main(int argc, char*argv[])
   {
       const char*mytalents[LIM] = {
           "Adding numbers swiftly",
           "Multiplying accurately", "Srashing data",
           "Following instructions to the letter",
           "Understanding the C language"
       };
       char youtalents[LIM][SLEN] = {
           "Walking in a straight line",
           "Sleeping", "Watching television",
           "Mailing letters", "Reading email"
       };
       int i;
       puts("Let's compare talents.");
       printf("%-36s %-25s\n", "My Talents", "Your Talents");
       for (i = 0; i < LIM; i++)
           printf("%-36s %-25s\n", mytalents[i], yourtalents[i]);
       printf("\nsizeof mytalents: %zd, sizeof yourtalents: %zd\n",
             sizeof(mytalents), sizeof(yourtalents));
       return 0;
   
   ```

   * 从某些方面来看，`mytalents`和`yourtalents`非常相似。两者都代表5个字符
     串。
   * 使用一个下标时都分别表示一个字符串，如`mytalents[0]`和`yourtalents[0]；`使用两个下标时都分别表示一个字符，例如 `mytalents[1][2]`表示 `mytalents`数组中第2个指针所指向的字符串的第3个字符`'l'`，`yourtalents[1][2]`表示youttalentes`数组的第2个字符串的第3个字符`'e'`。而且，两者的初始化方式也相同。
   * 但是，它们也有区别。**`mytalents`数组是一个内含5个指针的数组，**在我们的系统中共占用40字节。**而`yourtalents`是一个内含5个数组的数组，**每个数
     组内含40个`char`类型的值，共占用200字节。所以，虽然`mytalents[0]`和
     `yourtalents[0]`都分别表示一个字符串，但`mytalents`和`yourtalents`的类型并不相同。
   * `mytalents`中的指针指向初始化时所用的字符串字面量的位置，这些字符
     串字面量被储存在静态内存中；而 `yourtalents` 中的数组则储存着字符串字面
     量的副本，所以每个字符串都被储存了两次。
   * 此外，`yourtalents`为字符串数组分配内存的使用率较低。`yourtalents` 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。
   * 我们可以把`yourtalents`想象成矩形二维数组，每行的长度都是40字节；
     把`mytalents`想象成不规则的数组，每行的长度不同。

<img src="note%20for%20C.assets/image-20210104215008240.png" alt="image-20210104215008240" style="zoom:50%; float:left" />

* 综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。
* `mytalents` 中的指针指向的字符串字面量不能更改；而`yourtalentsde` 中的内容
  可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。



### 指针和字符串

涉及浅拷贝与深拷贝。字符串的绝大多数操作都是通过指针完成的

* 通常，程序要完成某项操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用`strcpy()`或`strncpy()`函数



## 字符串输入

* 如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串



### 分配空间

* 最简单的方法是，在声明时显式指明数组的大小：
  * `char name[81];`
* 还有一种方式是使用C库函数来分配内存
  * `malloc()`
* 为字符串分配内存后，便可读入字符串，C库提供的读取字符串的函数有：
  * `scanf(), gets(), fgets()`



### 不幸的gets()函数

* 在拂去字符串时，`scanf()`和转换说明`%s`只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。
* `gets()`函数读取整行输入，直到遇到换行符`\n`，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。
* `gets()`函数经常和`puts()`函数配合使用，该函数用于显示字符串，并在末尾添加换行符。
* `gets()`的缺点在于它只有一个参数，即内存地址。因此它无法检查数组是否装得下输入行。如果输入的字符串过长，会导致缓冲区溢出（buffer overflow）



### gets()函数的替代品

* 过去常用`fgets()`来代替`gets()`。C11标准新增的`gets_s()`函数也可代替`gets()`

#### 1. fgets()函数和fputs()函数

* `fgets()`函数通过第2个参数限制读入的字符数来解决溢出的问题 
* `fgets()`函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么`fgets()`将读入n-1个字符，或者读到遇到的第一个换行符为止。
  * 如果待输入的字符串长度大于n，那么剩下的字符将会暂存在缓冲区等待下一次读入
  * 如果下一条读取语句要读取的是 double 类型的值，就可能导致程序崩溃。
  * 丢弃输入行余下的字符可以保证读取语句与键盘输入同步。
* 如果`fgets()`读到一个换行符，会把它储存在字符串中。这点与`gets()`不同，`gets()`会丢弃换行符。
* `fgets()`函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以`stdin`（标准输入）作为参数，该标识符定义在`stdio.h`中。
  * `fgets(arr, 11, stdin);`
  * `gets(arr);`

* `fputs()`的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用`stdout`（标准输出）作为该参数。`fputs()`与`puts()`的区别在于前者不会在输出时添加换行符，后者则会在待输出字符串末尾自动添加一个换行符。

* `fputs()`函数返回指向`char`的指针。如果一切进行顺利，该函数返回的地址与传入的第 1 个参数相同。

* 但是，如果函数读到文件结尾（待输入对象的结尾），它将返回一个特殊的指针：空指针（null pointer）

* **该指针保证不会指向有效的数据**，所以可用于标识这种特殊情况。在代码中，可以用数字0来代替，不过在C语言中用宏`NULL`来代替更常见（如果在读入数据时出现某些错误，该函数也返回`NULL`）。

* `fgets()`储存换行符有好处也有坏处。

  * 坏处是你可能并不想把换行符储存在字符串中，这样的换行符会带来一些麻烦。
  * 好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行。如果不是一整行，要妥善处理一行中剩下的字符。

* 如何处理掉换行符？一个方法是在已储存的字符串中查找换行符，并将其替换成空字符：

  ```C
  while (words[i] != '\n') // 假设\n在words中
  i++;
  words[i]　=　'\0';
  ```

* 如果仍有字符串留在输入行怎么办？一个可行的办法是，如果目标数组装不下一整行输入，就丢弃那些多出的字符：

  ```c
  while (getchar() != '\n') // 读取但不储存输入，包括\n
      continue;
  ```



##### 空字符和空指针

* 空字符（或'\0'）是用于标记C字符串末尾的字符，其对应字符编码是0。由于其他字符的编码不可能是 0，所以不可能是字符串的一部分。

* 空指针（或`NULL`）有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示某些特殊情况发生，例如遇到文件结尾或未能按预期执行。
* 空字符是整数类型，而空指针是指针类型。 
* 两者有时容易混淆的原因是：它们都可以用数值0来表示。
* 但是，从概念上看，两者是不同类型的0。
* 另外，**空字符是一个字符，占1字节；而空指针是一个地址，通常占4字节。**



#### 2. gets_s()函数

* `gets_s()`的待输入参数是两个：数组地址和长度（`fgets()`需要三个）
* 如果`gets_s()`读到换行符，会丢弃它而不是储存它。
* 只要输入行未超过最大字符数，`gets_s()`和`gets()`几乎一样，完全可以用`gets_s()`替换`gets()`。



#### 3. s_gets()函数

```c
char*s_gets(char*st, int n)
{
    char*ret_val;
    int i = 0;
    ret_val = fgets(st, n, stdin);
    if (ret_val) // 即 ret_val ！= NULL，开始替换其中的空字符，并丢弃多余的字符
    {
        while (st[i] != '\n' && st[i] != '\0')
            i++;
        if (st[i] == '\n')
            st[i] = '\0';
        else
            while (getchar() != '\n')// 丢弃多余字符
                continue;
    }
    return ret_val;
}
```



### scanf()函数

* 可以使用`scanf()`和`%s`转换说明来读取字符串。`scanf()`和`gets()`或`fgets()`的区别在于它们如何确定字符串的末尾。
  * 如果预留的存储区装得下输入行，`gets()`和`fgets()`会读取第1个换行符之前所有的字符。
  * `scanf()`函数有两种方法确定输入结束。无论哪种方法，都从第1个非空白字符作为字符串的开始。如果使用`%s`转换说明，以下一个空白字符（空行、空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。
  * 如果指定了字段宽度，如`%10s`，那么`scanf()`将读取10个字符或读到第1个空白字符停止（先满足的条件即是结束输入的条件）

![image-20210112210136254](note%20for%20C.assets/image-20210112210136254.png)

* `scanf()`函数返回一个整数值，该值等于`scanf()`成功读取的项数或`EOF`（读到文件结尾时返回`EOF`）。

* 根据输入数据的性质，用`fgets()`读取从键盘输入的数据更合适。如果一次只输入一个单词，用`scanf()`也没问题。
* `scanf()`和`gets()`类似，也存在一些潜在的缺点。如果输入行的内容过长，`scanf()`也会导致数据溢出。在`%s`转换说明中使用字段宽度可防止溢出。



## 字符串输出

C有3个标准库函数用于打印字符串：`put()`、`fputs()`和`printf()`。



### puts()函数

* `puts()`函数很容易使用，只需把字符串的地址作为参数传递给它即可。
* 在显示字符串时`puts()`会自动在其末尾添加一个换行符。
* `puts()`在遇到空字符时停止输出，**所以必须确保有空字符。**



### fputs()函数

* `fputs()`函数是`puts()`针对文件定制的版本
* `fputs()`函数的第 2 个参数指明要写入数据的文件。如果要打印在显示器上，可以用定义在`stdio.h`中的`stdout`（标准输出）作为该参数。
* `fputs()`不会在输出的末尾添加换行符。
* `puts()`应与`gets()`配对使用，`fputs()`应与`fgets()`配对使用。



### printf()函数

* `printf()`不会自动在每个字符串末尾加上一个换行符。因此，必须在参数中指明应该在哪里使用换行符。
* `printf()`的形式更复杂些，需要输入更多代码，而且计算机执行的时间也更长（但是你觉察不到）。然而，使用 `printf()`打印多个字符串更加简单。



## 自定义输入/输出函数

* 不一定非要使用C库中的标准函数，如果无法使用这些函数或者不想用它们，完全可以在`getchar()`和`putchar()`的基础上自定义所需的函数。

```c
/* put1.c -- 打印字符串，不添加\n*/
#include <stdio.h>
void put1(const char*string)/* 不会改变字符串*/
{
    while(*string)// 相当于 while(*string != '\0')
        putchar(*string++) //++ 的运算级高于 *，因此是先改变地址，再取值
}
```

* 用指针编写上述函数无需定义索引变量，比数组简单一些
* 用`while(*string)`而不是`while(*string != 0)`要更加简洁。这种处理方法很普遍，作为C程序员应该熟悉这种写法。
  * 也就是熟悉常见库函数的返回值与函数值，并与布尔值联系起来

```c
/* put2.c -- 打印一个字符串，并统计打印的字符数*/
#include <stdio.h>
int put2(const char*string)
{
    int count = 0;
    while(*string) /*常规用法*/
    {
        putchar(*string++);
        count++;
    }
    putchar('\n'); /* 不统计换行符*/
    return(count);
}
```



## 字符串函数

C库提供了多个处理字符串的函数，函数的原型在`string.h`头文件中，常用的函数有`strlen(), strcat(), strcmp(), strncmp(), strcpy(), strncpy()`。还有`sprintf()`函数，其原型在`stdio.h`头文件中。



### strlen()函数

* `strlen()`函数用于统计字符串的长度

* 区分空格和'\0'

  ![image-20210112223359482](note%20for%20C.assets/image-20210112223359482.png)

### strcat()函数

* `strcat()`用于拼接字符串，该函数接受两个字符串作为参数，把第2个字符串的**备份**附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。
* `strcat()`的类型是`char*`（即指向`char`的指针）。`strcat()`函数返回第1个参数，即拼接后的字符串的地址



### strncat()函数

* `strcat()`函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。
  * 注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。
* `strncat()`函数的第3个参数指定了最大添加字符数。
  * `strncat(bugs, addon, 13)`将把 `addon`字符串的内容附加给`bugs`，在加到第13个字符或遇到空字符时停止。

* `strcat()`和 `gets()`类似，也会导致缓冲区溢出。



### strcmp()函数

* 用于字符串内容比较，（不是地址比较）。
* 该函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参数相同，该函数就返回0，否则返回非零值。
  * `while(strcmp(try, ANSWER))`
* `strcmp()`函数比较的是字符串，不是整个数组，也就是第一个空字符前面的部分。因此可以用`strcmp()`比较储存在不同大小数组中的字符串。
* `strcmp()`函数比较的是字符串，不是字符，所以其参数应该是字符串（如`"apples"`和`"A"`），而不是字符（如`'A'`）。但是，`char` 类型实际上是整数
  类型，所以可以使用关系运算符来比较字符。



### strncpm()函数

* `strcmp()`函数比较字符串中的字符，直到发现不同的字符为止，这一过
  程可能会持续到字符串的末尾。
* 而`strncmp()`函数在比较两个字符串时，可以比较到字符不同的地方，也可以只比较第3个参数指定的字符数。



### strcpy()和strncpy()函数

* 如果pts1和pts2都是指向字符串的指针，那么下面语句拷贝的是字符串的地址而不是字符串本身：
  * `pts2 = pts1;`
* 如果希望拷贝整个字符串，要使用`strcpy()`函数。`strcpy()`函数相当于字符串赋值运算符。
* `strcpy()`第2个参数指向的字符串**被拷贝至**第1个参数指向的数组中。拷贝出来的字符串被称为目标字符串，最初的字符串被称为源字符串。
* 参考赋值表达式语句，很容易记住`strcpy()`参数的顺序，即第1个是目标字符串，第2个是源字符串。
* `strcpy()`接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；而指向源字符串副本的第1个指针应指向**一个数据对象（如，数组）**，且该对象有足够的空间储存源字符串的副本。
* 记住，**声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间。**
  * 如果要通过指针的分配存储空间，需要用到`malloc()`函数
* 





# 第十四章 结构和其他数据形式

## 实例问题：创建图书目录

* 打印图书目录，需要一种既能包含字符串，又能包含数字的数据形式，而且还要保持各信息的独立

* 如果用多个不同的数组分别记录图书目录的每一项则比较繁琐

* C语言中的结构变量(structure variable)就满足了这种情况下的需求

  * 声明格式：

  ​        struct name

  ​       {

  

  ​        };  // 创建了一个name类型的结构体变量

  * 使用格式：struct name var1; // 把var1声明为一个book类型的变量6

    ```c
    /* book.c -- 一本书的图书目录 */
    #include <stdio.h>
    #include <string.g>
    char *s_gets(char *st, int n);
    #define MAXTITL 41  /* 书名的最大长度 +1*/
    #define MAXAUTL 31  /* 作者姓名的最大长度 +1 */
    struct book{
        char title[MAXTITL];
        char author[MAXAUTL];
        float value;
    };
    
    ```

